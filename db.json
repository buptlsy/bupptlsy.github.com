{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/suolong.jpg","path":"images/suolong.jpg","modified":1,"renderable":0},{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"1cbc8c478552e7263ee236cec9aeae110fa53ab5","modified":1467942260000},{"_id":"themes/hexo-theme-next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1464103895000},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1464103895000},{"_id":"themes/hexo-theme-next/.gitignore","hash":"efec790f5b7a0256763e1cc08f12c4f0aff509f6","modified":1464103895000},{"_id":"themes/hexo-theme-next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1464103895000},{"_id":"themes/hexo-theme-next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1464103895000},{"_id":"themes/hexo-theme-next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1464103895000},{"_id":"themes/hexo-theme-next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1464103895000},{"_id":"themes/hexo-theme-next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1464103895000},{"_id":"themes/hexo-theme-next/_config.yml","hash":"391ba2b66aa3dcd33239c30888d8376727be3972","modified":1469001171000},{"_id":"themes/hexo-theme-next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1464103895000},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1464103895000},{"_id":"themes/hexo-theme-next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1464103895000},{"_id":"source/_posts/countDownLatch.md","hash":"0a0d1c73dcaeb009fb3de5dc3add29d5fe52fba3","modified":1464527987000},{"_id":"source/_posts/hello-world.md","hash":"41ea9d411f68f0e0a256ca6844785be1a469010a","modified":1464142268000},{"_id":"source/_posts/jvm-args.md","hash":"9b48e90fcb15252a246d1cce6349f88a41a70095","modified":1468979317000},{"_id":"source/_posts/abstractQueuedSynchronizer.md","hash":"f6a47bf12ea27e0bc47ec0113aa004b065c9c505","modified":1464444351000},{"_id":"source/_posts/jdk_tools.md","hash":"c7b1512780375ab39391dccd991fd6f04ef706cf","modified":1468899086000},{"_id":"source/_posts/linux_performance_monitoring.md","hash":"403f6330aa5396d9e9a7f9db2657258942d9b355","modified":1468919589000},{"_id":"source/_posts/mysql-enviroment.md","hash":"d7118406a163f8f82a9179315b4fd2b1059dbbb0","modified":1465301028000},{"_id":"source/_posts/jvm-outofmemory.md","hash":"4ed1562476cf50ce5b5aac81d15a530c61e436b0","modified":1468997752000},{"_id":"source/_posts/redis_hash.md","hash":"ae5e09dccba212dad075d7a0f010ed4abdab1fe7","modified":1465796865000},{"_id":"source/_posts/theadlocal.md","hash":"7a982bef7449b433b04a2516fa92d02eabfa78c9","modified":1469095762000},{"_id":"source/_posts/redis_sds_list.md","hash":"8bdb9ab964d856154cbbd6ddb113bc5817aa8be2","modified":1464958545000},{"_id":"source/_posts/mysql-index.md","hash":"30cf3aac3483e2990eff572ff3f91ffe20dbd319","modified":1466748186000},{"_id":"source/_posts/synchronized_volatile.md","hash":"29197cf371419d3998c1bb3a8b997cfe74b1026a","modified":1464250893000},{"_id":"source/_posts/单例模式实现方式.markdown","hash":"85935d1f3168ad22a8909dd6201edd71e9f307d8","modified":1464182134000},{"_id":"source/about/.DS_Store","hash":"cbcffa814bed92f9f7071dd89a36ea2875ebba11","modified":1467942260000},{"_id":"source/about/index.md","hash":"96b2de85ae0e4c0573689ff3874ace29e18a3e80","modified":1468567598000},{"_id":"source/images/suolong.jpg","hash":"a7d3853060cd0f82011c415e82c3c027c9213548","modified":1468999569000},{"_id":"source/_posts/wait_notify.md","hash":"550846be1017fb302a2b9f3577a96835ac9768ac","modified":1464157292000},{"_id":"source/tags/index.md","hash":"e273308487f4f01cbcc22669b639f870ddbfb2b1","modified":1464141634000},{"_id":"source/tags/index-1.md","hash":"93396b78bbcf72182426bf820895ffc2704d921d","modified":1466662353000},{"_id":"source/categories/index.md","hash":"0f95777f60c102cbd14ccfcc05d4e6ce1665e211","modified":1464141404000},{"_id":"themes/hexo-theme-next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1464103895000},{"_id":"themes/hexo-theme-next/.git/config","hash":"ca83ce520f770c3104c997d323b9f293dd920073","modified":1464103895000},{"_id":"themes/hexo-theme-next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1464103665000},{"_id":"themes/hexo-theme-next/.git/index","hash":"0845d913f8118c1ad7fa98123b9f0fb0bfbabe72","modified":1464103907000},{"_id":"themes/hexo-theme-next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1464103895000},{"_id":"themes/hexo-theme-next/.git/packed-refs","hash":"320179d93925bb90c1b023203a4fdb929dd552ae","modified":1464103895000},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1464103895000},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1464103895000},{"_id":"themes/hexo-theme-next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1464103895000},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1464103895000},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1464103895000},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1464103895000},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1464103895000},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1464103895000},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1464103895000},{"_id":"themes/hexo-theme-next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1464103895000},{"_id":"themes/hexo-theme-next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1464103895000},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1464103895000},{"_id":"themes/hexo-theme-next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1464103895000},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1464103895000},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1464103895000},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464103895000},{"_id":"themes/hexo-theme-next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1464103665000},{"_id":"themes/hexo-theme-next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1464103665000},{"_id":"themes/hexo-theme-next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1464103665000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1464103665000},{"_id":"themes/hexo-theme-next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1464103665000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1464103665000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1464103665000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1464103665000},{"_id":"themes/hexo-theme-next/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1464103665000},{"_id":"themes/hexo-theme-next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1464103665000},{"_id":"themes/hexo-theme-next/.git/logs/HEAD","hash":"388b798c712d6fbaa944c11d194bc0d5c4b77c42","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"7719141a5a4482fa2461143625090888e693e99a","modified":1466670440000},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"85327c2174d09c6d69c9033592e6c8f7eb7ac3ba","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"0ce71d8322ea7dea82d9371fa2fe13949aa870e3","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"b883289054ee54a374caad5d4883591beb94bd8b","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/header.swig","hash":"963a765dc00e6ac43cfc53ffaf5725eb854cf95e","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/head.swig","hash":"f83b1c55bedd2c1a3eb734c72c6997795a4e5f99","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1464103895000},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1464103895000},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1464103895000},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464103895000},{"_id":"themes/hexo-theme-next/.git/refs/heads/master","hash":"4ef9f91c1cc6d025b6873e0ccf647436959bf219","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/lean-analytics.swig","hash":"069bb17fb1db3bc7c85c88efa3ed94ab6becbe2c","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/localsearch.swig","hash":"1561bd0c107d725252c6d746e9ac177fc18f93bf","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1464103895000},{"_id":"themes/hexo-theme-next/.git/logs/refs/heads/master","hash":"388b798c712d6fbaa944c11d194bc0d5c4b77c42","modified":1464103895000},{"_id":"themes/hexo-theme-next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1464103895000},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-bf1411dc3b879233501bd7eb5c029d28b9cf51da.idx","hash":"1cb2ab787e7d0a37fa0c610953fd352de339e7c0","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"44e761721e8ad787ef571a3cc57bbc12d318a2a3","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"8c7af79407d223486fba72b8150fe045a553bf70","modified":1464103895000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/disqus.swig","hash":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1464103895000},{"_id":"themes/hexo-theme-next/.git/logs/refs/remotes/origin/HEAD","hash":"388b798c712d6fbaa944c11d194bc0d5c4b77c42","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1464103895000},{"_id":"themes/hexo-theme-next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1464103895000},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-bf1411dc3b879233501bd7eb5c029d28b9cf51da.pack","hash":"d0bad1ce21e844c462f3d8f8b7ea37a58efdb5a0","modified":1464103895000},{"_id":"public/about/index.html","hash":"0b06822dd91818b7cd1e4f2c49d7fce1cd91a9cf","modified":1469095782099},{"_id":"public/tags/index.html","hash":"2b68142e40bf367e3f2142a40e531f209e8e6afa","modified":1469095782099},{"_id":"public/tags/index-1.html","hash":"9bfb2244cecbdc55fa61aee12ea58840efbb8c2f","modified":1469095782099},{"_id":"public/categories/index.html","hash":"a7190643c0e4aceba9ab090bb673e535197524e7","modified":1469095782099},{"_id":"public/2016/05/26/synchronized_volatile/index.html","hash":"426595d3d6805d17ebfc1c9c7488a69a19951c1a","modified":1469095782100},{"_id":"public/archives/page/2/index.html","hash":"ab8c8a7d244417045554950cbc8c472d8dbf7cbd","modified":1469095782100},{"_id":"public/archives/2016/page/2/index.html","hash":"2af44079dc9fc57ba72d136c5c62127f5edba8ca","modified":1469095782100},{"_id":"public/archives/2016/05/index.html","hash":"2bb551cd76ff89cd64bd35dabb86cb3e069ebf84","modified":1469095782100},{"_id":"public/archives/2016/06/index.html","hash":"17bd2733d463506b1028dc39f9f533bcfa4e19d8","modified":1469095782100},{"_id":"public/archives/2016/07/index.html","hash":"8c0e6412383b6aa878e1642c952f7fdf643eb5ab","modified":1469095782100},{"_id":"public/categories/java/index.html","hash":"c690e846120bde766767bd5137db501b51ccf1d4","modified":1469095782100},{"_id":"public/categories/hexo/index.html","hash":"14f41803a7eeb6231ef61cd6bb204396bc6e9708","modified":1469095782100},{"_id":"public/categories/linux/index.html","hash":"70e5ef7cae926430092f0946932dbad96afbeb59","modified":1469095782100},{"_id":"public/categories/redis/index.html","hash":"bd5fbe8dd6e6158c97afb5f72310622ae5388c1c","modified":1469095782100},{"_id":"public/categories/mysql/index.html","hash":"13f29b6a2fec132983007cf2396140fa4448cb63","modified":1469095782100},{"_id":"public/categories/设计模式/index.html","hash":"e55dcf8426f8825736b45e3b206d6e6c94d85e8d","modified":1469095782100},{"_id":"public/tags/java/index.html","hash":"560baa4bfb3642206f7df5ca79c43b56e42e8a13","modified":1469095782100},{"_id":"public/tags/hexo/index.html","hash":"cb755f65f9e2a5bbf4e3e9a1c6c6027aac5d4400","modified":1469095782101},{"_id":"public/tags/linux/index.html","hash":"1e52426624c9ec5bb9d7ff17bc8ff2dee5c445e7","modified":1469095782101},{"_id":"public/tags/mysql/index.html","hash":"69c529681993fe0d832de3b7354ccebea7187cb9","modified":1469095782101},{"_id":"public/tags/redis/index.html","hash":"2a2d5a3a0a6eb21c100022f063a939b6ee4c306d","modified":1469095782101},{"_id":"public/tags/msql/index.html","hash":"167ecd884ea6d7d4a154fcd42bbc22d51e18c099","modified":1469095782101},{"_id":"public/tags/java-设计模式/index.html","hash":"8b8bbc660087580dd5fadf4fa80db79edb864e7d","modified":1469095782101},{"_id":"public/2016/07/21/theadlocal/index.html","hash":"b606d947d113565bc1385ca529b5ebb3dd04d9ac","modified":1469095782101},{"_id":"public/2016/07/19/jvm-args/index.html","hash":"5dc4c3b24c8d4968119c64d5bc2bc52b9b6fe11a","modified":1469095782101},{"_id":"public/2016/07/20/jvm-outofmemory/index.html","hash":"c1c39b8e7e198aa0cfaf905f816bf660385a08bb","modified":1469095782101},{"_id":"public/2016/07/19/linux_performance_monitoring/index.html","hash":"d61e3dc54be8caa2bb3993ae58390c94c3db1147","modified":1469095782101},{"_id":"public/2016/07/19/jdk_tools/index.html","hash":"d50da3379138189aea6f7bc8bf54cb2eafe06a51","modified":1469095782101},{"_id":"public/2016/06/20/mysql-index/index.html","hash":"cf53f631db61630f0cd71f32269313d0170a8873","modified":1469095782102},{"_id":"public/2016/06/13/redis_hash/index.html","hash":"a510c69934c75dd06df3d130f94d309b2ef543c1","modified":1469095782102},{"_id":"public/2016/06/07/mysql-enviroment/index.html","hash":"98d3105fdc279b9e87a911131abfa32a3b86819a","modified":1469095782102},{"_id":"public/2016/06/03/redis_sds_list/index.html","hash":"0537d4b766b97e9dcd21c62a8a11afc81247f9ac","modified":1469095782102},{"_id":"public/2016/05/27/countDownLatch/index.html","hash":"49df90df19b48865f16566886e349dc2fb1f0869","modified":1469095782102},{"_id":"public/2016/05/27/abstractQueuedSynchronizer/index.html","hash":"c4d9498da30951ae79f70c813f9ee977baf297b8","modified":1469095782102},{"_id":"public/2016/05/25/单例模式实现方式/index.html","hash":"acae6b910ce6f9ae5429b2f46e9714f0e1076b38","modified":1469095782102},{"_id":"public/2016/05/25/wait_notify/index.html","hash":"1fe0af78893311caf8bbdbe170d6b41603305a88","modified":1469095782102},{"_id":"public/2016/05/24/hello-world/index.html","hash":"fcf70dcacc6ca7f3fce06513d97b1238ca7a0863","modified":1469095782102},{"_id":"public/archives/index.html","hash":"bed0569e79339ab966e04fca457a8eb395cdb1eb","modified":1469095782102},{"_id":"public/archives/2016/index.html","hash":"9da87ccf11c988d7a010d622ea784ceae0f1e68b","modified":1469095782102},{"_id":"public/index.html","hash":"57e4682f6d0e2f263f69a412a6ffc8fea90577ed","modified":1469095782102},{"_id":"public/page/2/index.html","hash":"e44de67db6df5d282eb5e9bcfceb7c2ba5e83181","modified":1469095782102},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1469095782102},{"_id":"public/images/suolong.jpg","hash":"a7d3853060cd0f82011c415e82c3c027c9213548","modified":1469095782103},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1469095782103},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1469095782104},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1469095782104},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1469095782104},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1469095782104},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1469095782104},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1469095782104},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1469095782979},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1469095782979},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1469095782981},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1469095782981},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1469095782981},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1469095782981},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1469095782981},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1469095782981},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1469095782981},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1469095782981},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1469095782981},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1469095782981},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1469095782981},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1469095782981},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1469095782981},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1469095782981},{"_id":"public/css/main.css","hash":"f6aba1e846dcc1b6af89eeaab8dc1d8fa7edf4fa","modified":1469095783006},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1469095783007},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1469095783015},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1469095783015},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1469095783020},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1469095783020},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1469095783020},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1469095783020},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1469095783020},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1469095783020},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1469095783020},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1469095783020},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1469095783020},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1469095783020},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1469095783021},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1469095783021},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1469095783021},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1469095783022},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1469095783022},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1469095783022},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1469095783022},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1469095783022},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1469095783022},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1469095783022},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1469095783022},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1469095783022},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1469095783022},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1469095783022},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1469095783022},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1469095783022},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1469095783022},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1469095783022},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1469095783022},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1469095783022},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1469095783022},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1469095783022},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1469095783022},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1469095783022},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1469095783022},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1469095783023},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1469095783023},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1469095783046}],"Category":[{"name":"java","_id":"ciqw5p2dl000533fye82v1vlh"},{"name":"hexo","_id":"ciqw5p2e7000j33fy9naag1jt"},{"name":"linux","_id":"ciqw5p2eb000r33fym1kay46e"},{"name":"mysql","_id":"ciqw5p2eh001033fyr79lqf3w"},{"name":"redis","_id":"ciqw5p2eq001833fyluc3m4hr"},{"name":"设计模式","_id":"ciqw5p2ey001m33fylfxe457r"}],"Data":[],"Page":[{"title":"分享ppt","date":"2016-07-15T07:16:14.000Z","_content":"# ppt分享\n\n[隐藏在“ssh关闭后，程序不能运行”的背后知识](http://buptlsy.github.io/images/about/ssh-signal.htm)\n\n","source":"about/index.md","raw":"---\ntitle: 分享ppt\ndate: 2016-07-15 15:16:14\n---\n# ppt分享\n\n[隐藏在“ssh关闭后，程序不能运行”的背后知识](http://buptlsy.github.io/images/about/ssh-signal.htm)\n\n","updated":"2016-07-15T07:26:38.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ciqw5p2df000133fyel4omqi9","content":"<h1 id=\"ppt分享\"><a href=\"#ppt分享\" class=\"headerlink\" title=\"ppt分享\"></a>ppt分享</h1><p><a href=\"http://buptlsy.github.io/images/about/ssh-signal.htm\" target=\"_blank\" rel=\"external\">隐藏在“ssh关闭后，程序不能运行”的背后知识</a></p>\n","excerpt":"","more":"<h1 id=\"ppt分享\"><a href=\"#ppt分享\" class=\"headerlink\" title=\"ppt分享\"></a>ppt分享</h1><p><a href=\"http://buptlsy.github.io/images/about/ssh-signal.htm\">隐藏在“ssh关闭后，程序不能运行”的背后知识</a></p>\n"},{"title":"tags","date":"2016-05-25T01:59:57.000Z","type":"“tags”","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-05-25 09:59:57\ntype: “tags”\n\n---\n","updated":"2016-05-25T02:00:34.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ciqw5p2di000333fyxf6mvgih","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-06-23T06:12:33.000Z","_content":"","source":"tags/index-1.md","raw":"---\ntitle: tags\ndate: 2016-06-23 14:12:33\n---\n","updated":"2016-06-23T06:12:33.000Z","path":"tags/index-1.html","comments":1,"layout":"page","_id":"ciqw5p2do000733fy6go3rc7w","content":"","excerpt":"","more":""},{"title":"categories","date":"2016-05-25T01:54:56.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-05-25 09:54:56\ntype: \"categories\"\n---\n","updated":"2016-05-25T01:56:44.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ciqw5p2ds000933fy0smebcd6","content":"","excerpt":"","more":""}],"Post":[{"title":"countDownLatch的使用和实现","_content":"countDownLatch实现了一种同步策略，允许一个或者多个线程等待直到一组操作被其他线程执行完成。\n<!--more-->\n### countDownLatch实现源码分析：\n\n    public class CountDownLatch {\n        //利用AQS实现Sync类，来表示count\n        private static final class Sync extends AbstractQueuedSynchronizer {\n            Sync(int count) {\n                setState(count);\n            }\n            \n            int getCount() {\n                return getCount();\n            }\n            \n            protected int tryAcquireShared(int acquires) {\n                return (getState == 0) ? 1 : -1;\n            }\n\n            protected boolean tryReleaseShared(int releases) {\n                for (;;) {\n                    int c = getState();\n                    if (c == 0) {\n                        return false;\n                    }\n                    int nextc = c - 1;\n                    if (compareAndSetState(c, nextc)) {\n                        return nextc == 0;\n                    }\n                }\n            }\n        }\n\n        private final Sync sync;\n\n        /*\n        * count：在线程可以通过之前，countDown()触发的次数。\n        */\n        private CoundDownLatch(int count) {\n            if (count < 0) throws new IlleagalArgumentException(\"count < 0\");\n            this.sync = new Sync();\n        }\n\n        /*\n        * 如果当前count减小到0，那么方法立即返回\n        * 如果当前count比0更大，那么当前线程阻塞。直到count减小到0或者一些其他的线程中断了当前线程\n        *  \n        */\n        public void await() throws InterruptedException {\n            sync.acquireSharedInterruptibly(1);\n        }\n        \n        /**\n        * 引起当前线程等待直到门栓值减到了0。除非这个线程被中断或者超过了指定的等待时间 。如果当前count=0，那么这个方法立即返回true。如果count>0,线程变为等待，直到下面3件事情发生：\n        * 1.count值变为0\n        * 2.超过了给定的等待时间\n        * 3.其他的线程中断了当前线程。如果当前线程有着中断状态设置在方法入口，或者当等待的时候被中断，那么会抛出InterruptedException并且当前线程的中断状态被清楚。\n        /\n        public boolean await(long time, TimeUnit unit) throws InterruptedException {\n            return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n        }\n\n        /**\n         * 减少门栓的count值。如果count减到0，释放所有的等待线程。\n         * 如果当前count值大于0，那么count减1；如果减少后的count值为0，则所有的等待线程变为可运行状态；如果当前的count为0，那么什么也不发生。\n         */\n        public void countDown() {\n            sync.releaseShared(1);\n        }\n\n        /**\n        * 返回当前count值。\n        * 这个方法主要是为了测试或者调试。\n        /\n        public long getCount() {\n            return sync.getCount();\n        }\n    }\n\n\n### countDownLatch的使用例子：\n典型用法 例子1：将一个问题分为N个部分，把每一部分描述为一个Runnable,并且减小门栓值，将所有的Runnables放进一个Executor中。当所有子部分完成时，协作线程将能够通过await。\n\n    class Driver {\n        void main() throws InterruptedException {\n            CountDownLatch doneSignal = new CountDownLatch(N);\n            Executor e = ...\n            for (int i = 0; i < N; i++) {\n                e.execute(new WorkerRunnable(doneSignal, i));\n            }\n            doneSignal.await(); //等待所有的线程结束\n        }\n    }\n\n    class WorkerRunnable implements Runnable {\n        private final CountDownLatch doneSignal;\n        private int i;\n        WorkerRunnable(CountDownLatch doneSignal, int i) {\n            this.doneSignal = doneSignal;\n            this.i = i;\n        }\n\n        public void run() {\n            try {\n                doWork(i);\n                doneSignal.countDown();\n            } catch (InterruptedException e) {\n            \n            }\n        }\n\n        void doWork() {...}\n    }\n    \n\n典型用法 例子2：第一个开始信号阻止工作线程通过指导driver是准备好让他们通过；第二个结束信号是等到所有worker结束了，driver才能运行。\n\n    class Driver {\n        CountDownLatch startSignal = new CountDownLatch(1);\n        CountDownLatch doneSignal = new CountDownLatch(N);\n\n        for (int i = 0; i < N; i++) {\n            new Thread(new Worker(startSignal, doneSignal)).start();\n        }\n        doSomethingElse();\n        startSignal.countDown();\n        doSomethingElse();\n        doneSignal.await();\n    }\n    \n    class Worker implements Runnable {\n        private final CountDownLatch startSignal;\n        private final CountDownLatch doneSignal;\n        Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {\n            this.startSignal = startSignal;\n            this.doneSignal = doneSignal;\n        }\n        public void run() {\n            try {\n                startSignal.await();\n                doWork();\n                doneSignal.countDown();\n            } catch (InterruptedException e) {\n            \n            }\n        }\n        void work() {...}\n    }\n\n\n问题：\n1.TimeUnit类的使用和原理。\n2.Memory consistency effects: Until the count reaches\n zero, actions in a thread prior to calling\n {@code countDown()}\n <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a>\n actions following a successful return from a corresponding\n {@code await()} in another thread.\n","source":"_posts/countDownLatch.md","raw":"---\ntitle: countDownLatch的使用和实现\ncategories: java\ntags: java\n---\ncountDownLatch实现了一种同步策略，允许一个或者多个线程等待直到一组操作被其他线程执行完成。\n<!--more-->\n### countDownLatch实现源码分析：\n\n    public class CountDownLatch {\n        //利用AQS实现Sync类，来表示count\n        private static final class Sync extends AbstractQueuedSynchronizer {\n            Sync(int count) {\n                setState(count);\n            }\n            \n            int getCount() {\n                return getCount();\n            }\n            \n            protected int tryAcquireShared(int acquires) {\n                return (getState == 0) ? 1 : -1;\n            }\n\n            protected boolean tryReleaseShared(int releases) {\n                for (;;) {\n                    int c = getState();\n                    if (c == 0) {\n                        return false;\n                    }\n                    int nextc = c - 1;\n                    if (compareAndSetState(c, nextc)) {\n                        return nextc == 0;\n                    }\n                }\n            }\n        }\n\n        private final Sync sync;\n\n        /*\n        * count：在线程可以通过之前，countDown()触发的次数。\n        */\n        private CoundDownLatch(int count) {\n            if (count < 0) throws new IlleagalArgumentException(\"count < 0\");\n            this.sync = new Sync();\n        }\n\n        /*\n        * 如果当前count减小到0，那么方法立即返回\n        * 如果当前count比0更大，那么当前线程阻塞。直到count减小到0或者一些其他的线程中断了当前线程\n        *  \n        */\n        public void await() throws InterruptedException {\n            sync.acquireSharedInterruptibly(1);\n        }\n        \n        /**\n        * 引起当前线程等待直到门栓值减到了0。除非这个线程被中断或者超过了指定的等待时间 。如果当前count=0，那么这个方法立即返回true。如果count>0,线程变为等待，直到下面3件事情发生：\n        * 1.count值变为0\n        * 2.超过了给定的等待时间\n        * 3.其他的线程中断了当前线程。如果当前线程有着中断状态设置在方法入口，或者当等待的时候被中断，那么会抛出InterruptedException并且当前线程的中断状态被清楚。\n        /\n        public boolean await(long time, TimeUnit unit) throws InterruptedException {\n            return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n        }\n\n        /**\n         * 减少门栓的count值。如果count减到0，释放所有的等待线程。\n         * 如果当前count值大于0，那么count减1；如果减少后的count值为0，则所有的等待线程变为可运行状态；如果当前的count为0，那么什么也不发生。\n         */\n        public void countDown() {\n            sync.releaseShared(1);\n        }\n\n        /**\n        * 返回当前count值。\n        * 这个方法主要是为了测试或者调试。\n        /\n        public long getCount() {\n            return sync.getCount();\n        }\n    }\n\n\n### countDownLatch的使用例子：\n典型用法 例子1：将一个问题分为N个部分，把每一部分描述为一个Runnable,并且减小门栓值，将所有的Runnables放进一个Executor中。当所有子部分完成时，协作线程将能够通过await。\n\n    class Driver {\n        void main() throws InterruptedException {\n            CountDownLatch doneSignal = new CountDownLatch(N);\n            Executor e = ...\n            for (int i = 0; i < N; i++) {\n                e.execute(new WorkerRunnable(doneSignal, i));\n            }\n            doneSignal.await(); //等待所有的线程结束\n        }\n    }\n\n    class WorkerRunnable implements Runnable {\n        private final CountDownLatch doneSignal;\n        private int i;\n        WorkerRunnable(CountDownLatch doneSignal, int i) {\n            this.doneSignal = doneSignal;\n            this.i = i;\n        }\n\n        public void run() {\n            try {\n                doWork(i);\n                doneSignal.countDown();\n            } catch (InterruptedException e) {\n            \n            }\n        }\n\n        void doWork() {...}\n    }\n    \n\n典型用法 例子2：第一个开始信号阻止工作线程通过指导driver是准备好让他们通过；第二个结束信号是等到所有worker结束了，driver才能运行。\n\n    class Driver {\n        CountDownLatch startSignal = new CountDownLatch(1);\n        CountDownLatch doneSignal = new CountDownLatch(N);\n\n        for (int i = 0; i < N; i++) {\n            new Thread(new Worker(startSignal, doneSignal)).start();\n        }\n        doSomethingElse();\n        startSignal.countDown();\n        doSomethingElse();\n        doneSignal.await();\n    }\n    \n    class Worker implements Runnable {\n        private final CountDownLatch startSignal;\n        private final CountDownLatch doneSignal;\n        Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {\n            this.startSignal = startSignal;\n            this.doneSignal = doneSignal;\n        }\n        public void run() {\n            try {\n                startSignal.await();\n                doWork();\n                doneSignal.countDown();\n            } catch (InterruptedException e) {\n            \n            }\n        }\n        void work() {...}\n    }\n\n\n问题：\n1.TimeUnit类的使用和原理。\n2.Memory consistency effects: Until the count reaches\n zero, actions in a thread prior to calling\n {@code countDown()}\n <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a>\n actions following a successful return from a corresponding\n {@code await()} in another thread.\n","slug":"countDownLatch","published":1,"date":"2016-05-27T09:21:48.000Z","updated":"2016-05-29T13:19:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2da000033fyzbwrqgfa","content":"<p>countDownLatch实现了一种同步策略，允许一个或者多个线程等待直到一组操作被其他线程执行完成。<br><a id=\"more\"></a></p>\n<h3 id=\"countDownLatch实现源码分析：\"><a href=\"#countDownLatch实现源码分析：\" class=\"headerlink\" title=\"countDownLatch实现源码分析：\"></a>countDownLatch实现源码分析：</h3><pre><code>public class CountDownLatch {\n    //利用AQS实现Sync类，来表示count\n    private static final class Sync extends AbstractQueuedSynchronizer {\n        Sync(int count) {\n            setState(count);\n        }\n\n        int getCount() {\n            return getCount();\n        }\n\n        protected int tryAcquireShared(int acquires) {\n            return (getState == 0) ? 1 : -1;\n        }\n\n        protected boolean tryReleaseShared(int releases) {\n            for (;;) {\n                int c = getState();\n                if (c == 0) {\n                    return false;\n                }\n                int nextc = c - 1;\n                if (compareAndSetState(c, nextc)) {\n                    return nextc == 0;\n                }\n            }\n        }\n    }\n\n    private final Sync sync;\n\n    /*\n    * count：在线程可以通过之前，countDown()触发的次数。\n    */\n    private CoundDownLatch(int count) {\n        if (count &lt; 0) throws new IlleagalArgumentException(&quot;count &lt; 0&quot;);\n        this.sync = new Sync();\n    }\n\n    /*\n    * 如果当前count减小到0，那么方法立即返回\n    * 如果当前count比0更大，那么当前线程阻塞。直到count减小到0或者一些其他的线程中断了当前线程\n    *  \n    */\n    public void await() throws InterruptedException {\n        sync.acquireSharedInterruptibly(1);\n    }\n\n    /**\n    * 引起当前线程等待直到门栓值减到了0。除非这个线程被中断或者超过了指定的等待时间 。如果当前count=0，那么这个方法立即返回true。如果count&gt;0,线程变为等待，直到下面3件事情发生：\n    * 1.count值变为0\n    * 2.超过了给定的等待时间\n    * 3.其他的线程中断了当前线程。如果当前线程有着中断状态设置在方法入口，或者当等待的时候被中断，那么会抛出InterruptedException并且当前线程的中断状态被清楚。\n    /\n    public boolean await(long time, TimeUnit unit) throws InterruptedException {\n        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n    }\n\n    /**\n     * 减少门栓的count值。如果count减到0，释放所有的等待线程。\n     * 如果当前count值大于0，那么count减1；如果减少后的count值为0，则所有的等待线程变为可运行状态；如果当前的count为0，那么什么也不发生。\n     */\n    public void countDown() {\n        sync.releaseShared(1);\n    }\n\n    /**\n    * 返回当前count值。\n    * 这个方法主要是为了测试或者调试。\n    /\n    public long getCount() {\n        return sync.getCount();\n    }\n}\n</code></pre><h3 id=\"countDownLatch的使用例子：\"><a href=\"#countDownLatch的使用例子：\" class=\"headerlink\" title=\"countDownLatch的使用例子：\"></a>countDownLatch的使用例子：</h3><p>典型用法 例子1：将一个问题分为N个部分，把每一部分描述为一个Runnable,并且减小门栓值，将所有的Runnables放进一个Executor中。当所有子部分完成时，协作线程将能够通过await。</p>\n<pre><code>class Driver {\n    void main() throws InterruptedException {\n        CountDownLatch doneSignal = new CountDownLatch(N);\n        Executor e = ...\n        for (int i = 0; i &lt; N; i++) {\n            e.execute(new WorkerRunnable(doneSignal, i));\n        }\n        doneSignal.await(); //等待所有的线程结束\n    }\n}\n\nclass WorkerRunnable implements Runnable {\n    private final CountDownLatch doneSignal;\n    private int i;\n    WorkerRunnable(CountDownLatch doneSignal, int i) {\n        this.doneSignal = doneSignal;\n        this.i = i;\n    }\n\n    public void run() {\n        try {\n            doWork(i);\n            doneSignal.countDown();\n        } catch (InterruptedException e) {\n\n        }\n    }\n\n    void doWork() {...}\n}\n</code></pre><p>典型用法 例子2：第一个开始信号阻止工作线程通过指导driver是准备好让他们通过；第二个结束信号是等到所有worker结束了，driver才能运行。</p>\n<pre><code>class Driver {\n    CountDownLatch startSignal = new CountDownLatch(1);\n    CountDownLatch doneSignal = new CountDownLatch(N);\n\n    for (int i = 0; i &lt; N; i++) {\n        new Thread(new Worker(startSignal, doneSignal)).start();\n    }\n    doSomethingElse();\n    startSignal.countDown();\n    doSomethingElse();\n    doneSignal.await();\n}\n\nclass Worker implements Runnable {\n    private final CountDownLatch startSignal;\n    private final CountDownLatch doneSignal;\n    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {\n        this.startSignal = startSignal;\n        this.doneSignal = doneSignal;\n    }\n    public void run() {\n        try {\n            startSignal.await();\n            doWork();\n            doneSignal.countDown();\n        } catch (InterruptedException e) {\n\n        }\n    }\n    void work() {...}\n}\n</code></pre><p>问题：<br>1.TimeUnit类的使用和原理。<br>2.Memory consistency effects: Until the count reaches<br> zero, actions in a thread prior to calling<br> {@code countDown()}<br> <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a><br> actions following a successful return from a corresponding<br> {@code await()} in another thread.</p>\n","excerpt":"<p>countDownLatch实现了一种同步策略，允许一个或者多个线程等待直到一组操作被其他线程执行完成。<br>","more":"</p>\n<h3 id=\"countDownLatch实现源码分析：\"><a href=\"#countDownLatch实现源码分析：\" class=\"headerlink\" title=\"countDownLatch实现源码分析：\"></a>countDownLatch实现源码分析：</h3><pre><code>public class CountDownLatch {\n    //利用AQS实现Sync类，来表示count\n    private static final class Sync extends AbstractQueuedSynchronizer {\n        Sync(int count) {\n            setState(count);\n        }\n\n        int getCount() {\n            return getCount();\n        }\n\n        protected int tryAcquireShared(int acquires) {\n            return (getState == 0) ? 1 : -1;\n        }\n\n        protected boolean tryReleaseShared(int releases) {\n            for (;;) {\n                int c = getState();\n                if (c == 0) {\n                    return false;\n                }\n                int nextc = c - 1;\n                if (compareAndSetState(c, nextc)) {\n                    return nextc == 0;\n                }\n            }\n        }\n    }\n\n    private final Sync sync;\n\n    /*\n    * count：在线程可以通过之前，countDown()触发的次数。\n    */\n    private CoundDownLatch(int count) {\n        if (count &lt; 0) throws new IlleagalArgumentException(&quot;count &lt; 0&quot;);\n        this.sync = new Sync();\n    }\n\n    /*\n    * 如果当前count减小到0，那么方法立即返回\n    * 如果当前count比0更大，那么当前线程阻塞。直到count减小到0或者一些其他的线程中断了当前线程\n    *  \n    */\n    public void await() throws InterruptedException {\n        sync.acquireSharedInterruptibly(1);\n    }\n\n    /**\n    * 引起当前线程等待直到门栓值减到了0。除非这个线程被中断或者超过了指定的等待时间 。如果当前count=0，那么这个方法立即返回true。如果count&gt;0,线程变为等待，直到下面3件事情发生：\n    * 1.count值变为0\n    * 2.超过了给定的等待时间\n    * 3.其他的线程中断了当前线程。如果当前线程有着中断状态设置在方法入口，或者当等待的时候被中断，那么会抛出InterruptedException并且当前线程的中断状态被清楚。\n    /\n    public boolean await(long time, TimeUnit unit) throws InterruptedException {\n        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n    }\n\n    /**\n     * 减少门栓的count值。如果count减到0，释放所有的等待线程。\n     * 如果当前count值大于0，那么count减1；如果减少后的count值为0，则所有的等待线程变为可运行状态；如果当前的count为0，那么什么也不发生。\n     */\n    public void countDown() {\n        sync.releaseShared(1);\n    }\n\n    /**\n    * 返回当前count值。\n    * 这个方法主要是为了测试或者调试。\n    /\n    public long getCount() {\n        return sync.getCount();\n    }\n}\n</code></pre><h3 id=\"countDownLatch的使用例子：\"><a href=\"#countDownLatch的使用例子：\" class=\"headerlink\" title=\"countDownLatch的使用例子：\"></a>countDownLatch的使用例子：</h3><p>典型用法 例子1：将一个问题分为N个部分，把每一部分描述为一个Runnable,并且减小门栓值，将所有的Runnables放进一个Executor中。当所有子部分完成时，协作线程将能够通过await。</p>\n<pre><code>class Driver {\n    void main() throws InterruptedException {\n        CountDownLatch doneSignal = new CountDownLatch(N);\n        Executor e = ...\n        for (int i = 0; i &lt; N; i++) {\n            e.execute(new WorkerRunnable(doneSignal, i));\n        }\n        doneSignal.await(); //等待所有的线程结束\n    }\n}\n\nclass WorkerRunnable implements Runnable {\n    private final CountDownLatch doneSignal;\n    private int i;\n    WorkerRunnable(CountDownLatch doneSignal, int i) {\n        this.doneSignal = doneSignal;\n        this.i = i;\n    }\n\n    public void run() {\n        try {\n            doWork(i);\n            doneSignal.countDown();\n        } catch (InterruptedException e) {\n\n        }\n    }\n\n    void doWork() {...}\n}\n</code></pre><p>典型用法 例子2：第一个开始信号阻止工作线程通过指导driver是准备好让他们通过；第二个结束信号是等到所有worker结束了，driver才能运行。</p>\n<pre><code>class Driver {\n    CountDownLatch startSignal = new CountDownLatch(1);\n    CountDownLatch doneSignal = new CountDownLatch(N);\n\n    for (int i = 0; i &lt; N; i++) {\n        new Thread(new Worker(startSignal, doneSignal)).start();\n    }\n    doSomethingElse();\n    startSignal.countDown();\n    doSomethingElse();\n    doneSignal.await();\n}\n\nclass Worker implements Runnable {\n    private final CountDownLatch startSignal;\n    private final CountDownLatch doneSignal;\n    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {\n        this.startSignal = startSignal;\n        this.doneSignal = doneSignal;\n    }\n    public void run() {\n        try {\n            startSignal.await();\n            doWork();\n            doneSignal.countDown();\n        } catch (InterruptedException e) {\n\n        }\n    }\n    void work() {...}\n}\n</code></pre><p>问题：<br>1.TimeUnit类的使用和原理。<br>2.Memory consistency effects: Until the count reaches<br> zero, actions in a thread prior to calling<br> {@code countDown()}<br> <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a><br> actions following a successful return from a corresponding<br> {@code await()} in another thread.</p>"},{"title":"jvm常用参数设置","_content":"jvm的参数包括：跟踪调试参数、堆参数、栈参数、方法区配置参数、直接内存参数和虚拟机的工作模式。\n<!--more-->\n# 跟踪调试参数\n## 跟踪垃圾收集\n-XX:+PrintGC,在虚拟机启动后，遇到GC，就会打印日志\n-XX:+PrintGCDetail 打印详细的GC日志.是虚拟机在退出前打印堆得详细信息，详细信息描述了当前堆得各个区的使用情况。\n-XX:+PrintHeapAtGC 在GC日志输出前后，都有详细的堆信息输出\n-XX:+PrintGCTimeStamps 输出GC发生的时间，该时间为虚拟机启动后的时间偏移量\n-XX:+PrintGCApplicationConcurrentTime 打印应用程序的执行时间\n-XX:+PrintGCApplicationStoppedTime 打印应用程序由于GC而产生的停顿时间\n-XX:+PrintReferenceGC 跟踪系统的软引用、弱引用、虚引用和Finallize队列\n\n## 跟踪类的加载、卸载\n-verbose:class 跟踪类的加载和卸载\n-XX:+TraceClassLoading 跟踪类的加载\n-XX:+TraceClassUnloading跟踪类的卸载\n\n## 系统参数查看\n-XX:+PrintVMOptions 打印虚拟机接受到的命令行显示参数\n-XX:+PrintCommandLineFlags 打印传递给虚拟机的显示和隐示参数，隐示参数是虚拟机启动时自行设置的。\n\n# 堆参数配置\n\n![堆参数配置示意图](https://raw.githubusercontent.com/buptlsy/images/gh-pages/heap-malloc-struct.png)\n\n# 非堆内存的参数配置\n## 方法区参数配置\n在jdk1.7和jdk1.6中，方法区的配置参数是：-XX:PermSize 指定初始的永久区大小，-XX:MaxPermSize 指定最大永久区\n在jdk1.8，永久区被移除，使用了元数据区存放类的元数据，元数据区只受系统可用内存大小的限制，但是可以通过-XX:MaxMetaspaceSize来指定永久区的最大可用值。\n\n## 栈参数配置\n-Xss 指定线程的栈大小\n\n## 直接内存参数配置\n直接内存跳过了java堆，可以直接访问原生堆空间。最大可用直接内存可以使用 -XX:MaxDirectMemeorySize 来设置，如不设置，默认值为最大堆空间，即-Xmx。当直接内存使用量达到最大值时，会出发垃圾收集。\n\n## jvm工作模式\n-client 指定client工作模式\n-server 指定server工作模式\n-version 查看工作模式是哪一种\n\nserver模式启动比较慢，因为会收集更多的性能参数，进行更多的性能优化\n","source":"_posts/jvm-args.md","raw":"title: jvm常用参数设置\ncategories: java\ntags: java\n\n---\njvm的参数包括：跟踪调试参数、堆参数、栈参数、方法区配置参数、直接内存参数和虚拟机的工作模式。\n<!--more-->\n# 跟踪调试参数\n## 跟踪垃圾收集\n-XX:+PrintGC,在虚拟机启动后，遇到GC，就会打印日志\n-XX:+PrintGCDetail 打印详细的GC日志.是虚拟机在退出前打印堆得详细信息，详细信息描述了当前堆得各个区的使用情况。\n-XX:+PrintHeapAtGC 在GC日志输出前后，都有详细的堆信息输出\n-XX:+PrintGCTimeStamps 输出GC发生的时间，该时间为虚拟机启动后的时间偏移量\n-XX:+PrintGCApplicationConcurrentTime 打印应用程序的执行时间\n-XX:+PrintGCApplicationStoppedTime 打印应用程序由于GC而产生的停顿时间\n-XX:+PrintReferenceGC 跟踪系统的软引用、弱引用、虚引用和Finallize队列\n\n## 跟踪类的加载、卸载\n-verbose:class 跟踪类的加载和卸载\n-XX:+TraceClassLoading 跟踪类的加载\n-XX:+TraceClassUnloading跟踪类的卸载\n\n## 系统参数查看\n-XX:+PrintVMOptions 打印虚拟机接受到的命令行显示参数\n-XX:+PrintCommandLineFlags 打印传递给虚拟机的显示和隐示参数，隐示参数是虚拟机启动时自行设置的。\n\n# 堆参数配置\n\n![堆参数配置示意图](https://raw.githubusercontent.com/buptlsy/images/gh-pages/heap-malloc-struct.png)\n\n# 非堆内存的参数配置\n## 方法区参数配置\n在jdk1.7和jdk1.6中，方法区的配置参数是：-XX:PermSize 指定初始的永久区大小，-XX:MaxPermSize 指定最大永久区\n在jdk1.8，永久区被移除，使用了元数据区存放类的元数据，元数据区只受系统可用内存大小的限制，但是可以通过-XX:MaxMetaspaceSize来指定永久区的最大可用值。\n\n## 栈参数配置\n-Xss 指定线程的栈大小\n\n## 直接内存参数配置\n直接内存跳过了java堆，可以直接访问原生堆空间。最大可用直接内存可以使用 -XX:MaxDirectMemeorySize 来设置，如不设置，默认值为最大堆空间，即-Xmx。当直接内存使用量达到最大值时，会出发垃圾收集。\n\n## jvm工作模式\n-client 指定client工作模式\n-server 指定server工作模式\n-version 查看工作模式是哪一种\n\nserver模式启动比较慢，因为会收集更多的性能参数，进行更多的性能优化\n","slug":"jvm-args","published":1,"date":"2016-07-19T13:08:48.000Z","updated":"2016-07-20T01:48:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2dg000233fy5t39z3fu","content":"<p>jvm的参数包括：跟踪调试参数、堆参数、栈参数、方法区配置参数、直接内存参数和虚拟机的工作模式。<br><a id=\"more\"></a></p>\n<h1 id=\"跟踪调试参数\"><a href=\"#跟踪调试参数\" class=\"headerlink\" title=\"跟踪调试参数\"></a>跟踪调试参数</h1><h2 id=\"跟踪垃圾收集\"><a href=\"#跟踪垃圾收集\" class=\"headerlink\" title=\"跟踪垃圾收集\"></a>跟踪垃圾收集</h2><p>-XX:+PrintGC,在虚拟机启动后，遇到GC，就会打印日志<br>-XX:+PrintGCDetail 打印详细的GC日志.是虚拟机在退出前打印堆得详细信息，详细信息描述了当前堆得各个区的使用情况。<br>-XX:+PrintHeapAtGC 在GC日志输出前后，都有详细的堆信息输出<br>-XX:+PrintGCTimeStamps 输出GC发生的时间，该时间为虚拟机启动后的时间偏移量<br>-XX:+PrintGCApplicationConcurrentTime 打印应用程序的执行时间<br>-XX:+PrintGCApplicationStoppedTime 打印应用程序由于GC而产生的停顿时间<br>-XX:+PrintReferenceGC 跟踪系统的软引用、弱引用、虚引用和Finallize队列</p>\n<h2 id=\"跟踪类的加载、卸载\"><a href=\"#跟踪类的加载、卸载\" class=\"headerlink\" title=\"跟踪类的加载、卸载\"></a>跟踪类的加载、卸载</h2><p>-verbose:class 跟踪类的加载和卸载<br>-XX:+TraceClassLoading 跟踪类的加载<br>-XX:+TraceClassUnloading跟踪类的卸载</p>\n<h2 id=\"系统参数查看\"><a href=\"#系统参数查看\" class=\"headerlink\" title=\"系统参数查看\"></a>系统参数查看</h2><p>-XX:+PrintVMOptions 打印虚拟机接受到的命令行显示参数<br>-XX:+PrintCommandLineFlags 打印传递给虚拟机的显示和隐示参数，隐示参数是虚拟机启动时自行设置的。</p>\n<h1 id=\"堆参数配置\"><a href=\"#堆参数配置\" class=\"headerlink\" title=\"堆参数配置\"></a>堆参数配置</h1><p><img src=\"https://raw.githubusercontent.com/buptlsy/images/gh-pages/heap-malloc-struct.png\" alt=\"堆参数配置示意图\"></p>\n<h1 id=\"非堆内存的参数配置\"><a href=\"#非堆内存的参数配置\" class=\"headerlink\" title=\"非堆内存的参数配置\"></a>非堆内存的参数配置</h1><h2 id=\"方法区参数配置\"><a href=\"#方法区参数配置\" class=\"headerlink\" title=\"方法区参数配置\"></a>方法区参数配置</h2><p>在jdk1.7和jdk1.6中，方法区的配置参数是：-XX:PermSize 指定初始的永久区大小，-XX:MaxPermSize 指定最大永久区<br>在jdk1.8，永久区被移除，使用了元数据区存放类的元数据，元数据区只受系统可用内存大小的限制，但是可以通过-XX:MaxMetaspaceSize来指定永久区的最大可用值。</p>\n<h2 id=\"栈参数配置\"><a href=\"#栈参数配置\" class=\"headerlink\" title=\"栈参数配置\"></a>栈参数配置</h2><p>-Xss 指定线程的栈大小</p>\n<h2 id=\"直接内存参数配置\"><a href=\"#直接内存参数配置\" class=\"headerlink\" title=\"直接内存参数配置\"></a>直接内存参数配置</h2><p>直接内存跳过了java堆，可以直接访问原生堆空间。最大可用直接内存可以使用 -XX:MaxDirectMemeorySize 来设置，如不设置，默认值为最大堆空间，即-Xmx。当直接内存使用量达到最大值时，会出发垃圾收集。</p>\n<h2 id=\"jvm工作模式\"><a href=\"#jvm工作模式\" class=\"headerlink\" title=\"jvm工作模式\"></a>jvm工作模式</h2><p>-client 指定client工作模式<br>-server 指定server工作模式<br>-version 查看工作模式是哪一种</p>\n<p>server模式启动比较慢，因为会收集更多的性能参数，进行更多的性能优化</p>\n","excerpt":"<p>jvm的参数包括：跟踪调试参数、堆参数、栈参数、方法区配置参数、直接内存参数和虚拟机的工作模式。<br>","more":"</p>\n<h1 id=\"跟踪调试参数\"><a href=\"#跟踪调试参数\" class=\"headerlink\" title=\"跟踪调试参数\"></a>跟踪调试参数</h1><h2 id=\"跟踪垃圾收集\"><a href=\"#跟踪垃圾收集\" class=\"headerlink\" title=\"跟踪垃圾收集\"></a>跟踪垃圾收集</h2><p>-XX:+PrintGC,在虚拟机启动后，遇到GC，就会打印日志<br>-XX:+PrintGCDetail 打印详细的GC日志.是虚拟机在退出前打印堆得详细信息，详细信息描述了当前堆得各个区的使用情况。<br>-XX:+PrintHeapAtGC 在GC日志输出前后，都有详细的堆信息输出<br>-XX:+PrintGCTimeStamps 输出GC发生的时间，该时间为虚拟机启动后的时间偏移量<br>-XX:+PrintGCApplicationConcurrentTime 打印应用程序的执行时间<br>-XX:+PrintGCApplicationStoppedTime 打印应用程序由于GC而产生的停顿时间<br>-XX:+PrintReferenceGC 跟踪系统的软引用、弱引用、虚引用和Finallize队列</p>\n<h2 id=\"跟踪类的加载、卸载\"><a href=\"#跟踪类的加载、卸载\" class=\"headerlink\" title=\"跟踪类的加载、卸载\"></a>跟踪类的加载、卸载</h2><p>-verbose:class 跟踪类的加载和卸载<br>-XX:+TraceClassLoading 跟踪类的加载<br>-XX:+TraceClassUnloading跟踪类的卸载</p>\n<h2 id=\"系统参数查看\"><a href=\"#系统参数查看\" class=\"headerlink\" title=\"系统参数查看\"></a>系统参数查看</h2><p>-XX:+PrintVMOptions 打印虚拟机接受到的命令行显示参数<br>-XX:+PrintCommandLineFlags 打印传递给虚拟机的显示和隐示参数，隐示参数是虚拟机启动时自行设置的。</p>\n<h1 id=\"堆参数配置\"><a href=\"#堆参数配置\" class=\"headerlink\" title=\"堆参数配置\"></a>堆参数配置</h1><p><img src=\"https://raw.githubusercontent.com/buptlsy/images/gh-pages/heap-malloc-struct.png\" alt=\"堆参数配置示意图\"></p>\n<h1 id=\"非堆内存的参数配置\"><a href=\"#非堆内存的参数配置\" class=\"headerlink\" title=\"非堆内存的参数配置\"></a>非堆内存的参数配置</h1><h2 id=\"方法区参数配置\"><a href=\"#方法区参数配置\" class=\"headerlink\" title=\"方法区参数配置\"></a>方法区参数配置</h2><p>在jdk1.7和jdk1.6中，方法区的配置参数是：-XX:PermSize 指定初始的永久区大小，-XX:MaxPermSize 指定最大永久区<br>在jdk1.8，永久区被移除，使用了元数据区存放类的元数据，元数据区只受系统可用内存大小的限制，但是可以通过-XX:MaxMetaspaceSize来指定永久区的最大可用值。</p>\n<h2 id=\"栈参数配置\"><a href=\"#栈参数配置\" class=\"headerlink\" title=\"栈参数配置\"></a>栈参数配置</h2><p>-Xss 指定线程的栈大小</p>\n<h2 id=\"直接内存参数配置\"><a href=\"#直接内存参数配置\" class=\"headerlink\" title=\"直接内存参数配置\"></a>直接内存参数配置</h2><p>直接内存跳过了java堆，可以直接访问原生堆空间。最大可用直接内存可以使用 -XX:MaxDirectMemeorySize 来设置，如不设置，默认值为最大堆空间，即-Xmx。当直接内存使用量达到最大值时，会出发垃圾收集。</p>\n<h2 id=\"jvm工作模式\"><a href=\"#jvm工作模式\" class=\"headerlink\" title=\"jvm工作模式\"></a>jvm工作模式</h2><p>-client 指定client工作模式<br>-server 指定server工作模式<br>-version 查看工作模式是哪一种</p>\n<p>server模式启动比较慢，因为会收集更多的性能参数，进行更多的性能优化</p>"},{"title":"hexo 的基本操作","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!--more-->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: hexo 的基本操作\ncategories: hexo\ntags: hexo\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!--more-->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2016-05-24T06:13:55.000Z","updated":"2016-05-25T02:11:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2dm000633fygdsa2miy","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.<br><a id=\"more\"></a></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.<br>","more":"</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>"},{"title":"abstractQueuedSynchronizer详解","_content":"abstractQueuedSynchronizer提供了一个依赖于先进先出的等待队列实现了阻塞锁和同步。这个类是利用一个表示状态的int值来为各种同步设计的。子类必须定义protect方法来改变状态（状态表示这个object是被获取还是释放）。其他的方法实现了所有的排队和阻塞机制。它支持排他锁和共享锁两种模式。例如读写锁。\n<!--more-->\n例子1：（利用abstractQueuedSynchronizer来实现互斥锁）\n    class Mutex implements Lock, Serializable {\n        private static class Sync extends AbstractQueuedSynchronizer {\n            protected boolean isHeldExclusively() {\n                return getState() == 1;\n            }\n            public boolean tryAcquire(int acquires) {\n                assert acquires == 1;\n                if (compareAndSetState(0, 1)) {\n                    setExclusiveOwnerThread(Thread.currentThread());\n                    return true;\n                }\n                return false;\n            }\n            protected boolean tryRelease(int release) {\n                assert release == 1;\n                if (getState() == 0) throw new IllegalMonitorStateException();\n                setExclusiveOwnerThread(null);\n                setState(0);\n                return true;\n            }\n            Condition newCondition() {\n                return new ConditionObject();\n            }\n            private void readObject(ObjectInputStream s) \n                throws IOException, ClassNotFoundException {\n                s.defaultReadObject();\n                setState(0);\n            }\n        }\n\n        private final Sync sync = new Sync();\n        public void lock() {\n            sync.acquire(1);\n        }\n        public boolean tryLock() {\n            return sync.tryAcquire(1);\n        }\n        public void unLock() {\n            sync.release(1);\n        }\n        public boolean isLocked() {\n            return sync.isHeldExclusively();\n        }\n        public Condition newCondition() {\n            return sync.newCondition();\n        }\n        public boolean hasQueuedThreads() {\n            return sync.hasQueuedThreads();\n        }\n        public void lockInterruptibly() throw InterruptedException {\n            sync.acquireInterruptibly(1);\n        }\n        public boolean tryLock(long timeout, TimeUnit unit) \n            throws InterruptedException {\n            return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n        }\n    }\n\n\n例子2：\n    \n","source":"_posts/abstractQueuedSynchronizer.md","raw":"---\ntitle: abstractQueuedSynchronizer详解\ncategories: java\ntags: java\n---\nabstractQueuedSynchronizer提供了一个依赖于先进先出的等待队列实现了阻塞锁和同步。这个类是利用一个表示状态的int值来为各种同步设计的。子类必须定义protect方法来改变状态（状态表示这个object是被获取还是释放）。其他的方法实现了所有的排队和阻塞机制。它支持排他锁和共享锁两种模式。例如读写锁。\n<!--more-->\n例子1：（利用abstractQueuedSynchronizer来实现互斥锁）\n    class Mutex implements Lock, Serializable {\n        private static class Sync extends AbstractQueuedSynchronizer {\n            protected boolean isHeldExclusively() {\n                return getState() == 1;\n            }\n            public boolean tryAcquire(int acquires) {\n                assert acquires == 1;\n                if (compareAndSetState(0, 1)) {\n                    setExclusiveOwnerThread(Thread.currentThread());\n                    return true;\n                }\n                return false;\n            }\n            protected boolean tryRelease(int release) {\n                assert release == 1;\n                if (getState() == 0) throw new IllegalMonitorStateException();\n                setExclusiveOwnerThread(null);\n                setState(0);\n                return true;\n            }\n            Condition newCondition() {\n                return new ConditionObject();\n            }\n            private void readObject(ObjectInputStream s) \n                throws IOException, ClassNotFoundException {\n                s.defaultReadObject();\n                setState(0);\n            }\n        }\n\n        private final Sync sync = new Sync();\n        public void lock() {\n            sync.acquire(1);\n        }\n        public boolean tryLock() {\n            return sync.tryAcquire(1);\n        }\n        public void unLock() {\n            sync.release(1);\n        }\n        public boolean isLocked() {\n            return sync.isHeldExclusively();\n        }\n        public Condition newCondition() {\n            return sync.newCondition();\n        }\n        public boolean hasQueuedThreads() {\n            return sync.hasQueuedThreads();\n        }\n        public void lockInterruptibly() throw InterruptedException {\n            sync.acquireInterruptibly(1);\n        }\n        public boolean tryLock(long timeout, TimeUnit unit) \n            throws InterruptedException {\n            return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n        }\n    }\n\n\n例子2：\n    \n","slug":"abstractQueuedSynchronizer","published":1,"date":"2016-05-27T01:47:00.000Z","updated":"2016-05-28T14:05:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2dr000833fyaniwt35w","content":"<p>abstractQueuedSynchronizer提供了一个依赖于先进先出的等待队列实现了阻塞锁和同步。这个类是利用一个表示状态的int值来为各种同步设计的。子类必须定义protect方法来改变状态（状态表示这个object是被获取还是释放）。其他的方法实现了所有的排队和阻塞机制。它支持排他锁和共享锁两种模式。例如读写锁。<br><a id=\"more\"></a><br>例子1：（利用abstractQueuedSynchronizer来实现互斥锁）<br>    class Mutex implements Lock, Serializable {<br>        private static class Sync extends AbstractQueuedSynchronizer {<br>            protected boolean isHeldExclusively() {<br>                return getState() == 1;<br>            }<br>            public boolean tryAcquire(int acquires) {<br>                assert acquires == 1;<br>                if (compareAndSetState(0, 1)) {<br>                    setExclusiveOwnerThread(Thread.currentThread());<br>                    return true;<br>                }<br>                return false;<br>            }<br>            protected boolean tryRelease(int release) {<br>                assert release == 1;<br>                if (getState() == 0) throw new IllegalMonitorStateException();<br>                setExclusiveOwnerThread(null);<br>                setState(0);<br>                return true;<br>            }<br>            Condition newCondition() {<br>                return new ConditionObject();<br>            }<br>            private void readObject(ObjectInputStream s)<br>                throws IOException, ClassNotFoundException {<br>                s.defaultReadObject();<br>                setState(0);<br>            }<br>        }</p>\n<pre><code>    private final Sync sync = new Sync();\n    public void lock() {\n        sync.acquire(1);\n    }\n    public boolean tryLock() {\n        return sync.tryAcquire(1);\n    }\n    public void unLock() {\n        sync.release(1);\n    }\n    public boolean isLocked() {\n        return sync.isHeldExclusively();\n    }\n    public Condition newCondition() {\n        return sync.newCondition();\n    }\n    public boolean hasQueuedThreads() {\n        return sync.hasQueuedThreads();\n    }\n    public void lockInterruptibly() throw InterruptedException {\n        sync.acquireInterruptibly(1);\n    }\n    public boolean tryLock(long timeout, TimeUnit unit) \n        throws InterruptedException {\n        return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n    }\n}\n</code></pre><p>例子2：</p>\n","excerpt":"<p>abstractQueuedSynchronizer提供了一个依赖于先进先出的等待队列实现了阻塞锁和同步。这个类是利用一个表示状态的int值来为各种同步设计的。子类必须定义protect方法来改变状态（状态表示这个object是被获取还是释放）。其他的方法实现了所有的排队和阻塞机制。它支持排他锁和共享锁两种模式。例如读写锁。<br>","more":"<br>例子1：（利用abstractQueuedSynchronizer来实现互斥锁）<br>    class Mutex implements Lock, Serializable {<br>        private static class Sync extends AbstractQueuedSynchronizer {<br>            protected boolean isHeldExclusively() {<br>                return getState() == 1;<br>            }<br>            public boolean tryAcquire(int acquires) {<br>                assert acquires == 1;<br>                if (compareAndSetState(0, 1)) {<br>                    setExclusiveOwnerThread(Thread.currentThread());<br>                    return true;<br>                }<br>                return false;<br>            }<br>            protected boolean tryRelease(int release) {<br>                assert release == 1;<br>                if (getState() == 0) throw new IllegalMonitorStateException();<br>                setExclusiveOwnerThread(null);<br>                setState(0);<br>                return true;<br>            }<br>            Condition newCondition() {<br>                return new ConditionObject();<br>            }<br>            private void readObject(ObjectInputStream s)<br>                throws IOException, ClassNotFoundException {<br>                s.defaultReadObject();<br>                setState(0);<br>            }<br>        }</p>\n<pre><code>    private final Sync sync = new Sync();\n    public void lock() {\n        sync.acquire(1);\n    }\n    public boolean tryLock() {\n        return sync.tryAcquire(1);\n    }\n    public void unLock() {\n        sync.release(1);\n    }\n    public boolean isLocked() {\n        return sync.isHeldExclusively();\n    }\n    public Condition newCondition() {\n        return sync.newCondition();\n    }\n    public boolean hasQueuedThreads() {\n        return sync.hasQueuedThreads();\n    }\n    public void lockInterruptibly() throw InterruptedException {\n        sync.acquireInterruptibly(1);\n    }\n    public boolean tryLock(long timeout, TimeUnit unit) \n        throws InterruptedException {\n        return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n    }\n}\n</code></pre><p>例子2：</p>"},{"title":"jdk内置工具的使用","_content":"\njdk内置工具对于查看监控java服务的运行情况、服务的性能问题分析十分有用。对于某些监控工具的运行，需要在服务器端配置参数，来方便客户端连接。\n<!--more-->\n# 设置远程监控的相关选项\n需要在server.sh启动脚本中加入以下参数：\n- 开启JVM远程监控 -Dcom.sun.management.jmxremote=true\n- 监控的IP地址 -Djava.rmi.server.hostname=192.168.91.166，远程进程所在主机的IP。\n- 监控的端口 -Dcom.sun.management.jmxremote.port=50013，这个端口值可以任意设置，但在之后用Jconsole连接这个远程进程的时候，远程进程中的port一定要和此处的设置一致，并且一定要和远程进程的服务端口区分开。\n- 是否禁用ssl验证 -Dcom.sun.management.jmxremote.ssl，false为禁用，true为启用。\n- 是否需要用户密码验证 -Dcom.sun.management.jmxremote.authenticate，false为不需要验证，true为需要验证。\n\n# jdk 内置工具介绍\n## jinfo\njinfo pid 查看进程的java系统参数以及vm参数.\n\n## jmap\n主要是查看堆的情况，也可以将堆信息dump下来。\n### jmap -heap pid \n查看java堆的使用情况\n\n```\nAttaching to process ID 6196, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.91-b14\n\nusing thread-local object allocation.\nParallel GC with 2 thread(s)\n\nHeap Configuration:\nMinHeapFreeRatio         = 0                    ＃-xx:MinHeapFreeRatio 设置jvm堆最小空闲比率\nMaxHeapFreeRatio         = 100                  #-xx:MaxHeapFreeRatio 设置jvm堆最大空闲比率\nMaxHeapSize              = 536870912 (512.0MB)  ＃设置jvm堆的最大大小\nNewSize                  = 89128960 (85.0MB)    ＃设置jvm堆的 新生代的默认大小\nMaxNewSize               = 178782208 (170.5MB)  ＃设置jvm堆的 新生代的最大大小\nOldSize                  = 179306496 (171.0MB)  ＃设置jvm堆的 老年代的大小\nNewRatio                 = 2                    ＃设置新生代和老年代的大小比例\nSurvivorRatio            = 8                    ＃设置新生代中的 eden区和survivor区的大小比值\nMetaspaceSize            = 21807104 (20.796875MB)＃jdk1.8，类似于jdk1.7中的 permsize\nCompressedClassSpaceSize = 1073741824 (1024.0MB) \nMaxMetaspaceSize         = 17592186044415 MB\nG1HeapRegionSize         = 0 (0.0MB)\n\nHeap Usage:\nPS Young Generation\nEden Space:\ncapacity = 82837504 (79.0MB)\nused     = 27614056 (26.334815979003906MB)\nfree     = 55223448 (52.665184020996094MB)\n33.33521010000494% used\nFrom Space:\ncapacity = 3145728 (3.0MB)\nused     = 1534048 (1.462982177734375MB)\nfree     = 1611680 (1.537017822265625MB)\n48.766072591145836% used\n                                                            \nTo Space:\ncapacity = 3145728 (3.0MB)\nused     = 0 (0.0MB)\nfree     = 3145728 (3.0MB)\n0.0% used\nPS Old Generation\ncapacity = 201850880 (192.5MB)\nused     = 49296248 (47.01256561279297MB)\nfree     = 152554632 (145.48743438720703MB)\n24.422112006645698% used\n\n26112 interned Strings occupying 2975608 bytes.\n```\n\n### jmap -histo pid \n查看堆内存中对象数量和大小\n对比：jmap -histo:live pid jvm会先出发gc，再进行统计\n\n```\nnum     #instances      #bytes  class name\n----------------------------------------------\n1:         52843       25434824  [B\n2:        204331       23624576  [C\n3:         26098        7198896  [I\n4:        116142        4724056  [Ljava.lang.Object;\n5:        161108        3866592  java.lang.String\n6:         27160        2390080  java.lang.reflect.Method\n7:         47005        1504160  java.io.ObjectStreamClass$WeakClassKey\n8:         45639        1460448  java.util.HashMap$Node\n9:         12598        1443432  [Ljava.util.HashMap$Node;\n10:        24589        1180272  java.util.HashMap\n```\n\n### jmap -dump:format=b,file=heapdump pid\n将当前内存使用的详细信息存储到文件中\n\n## jstack\n打印线程的栈信息\n参考：http://www.blogjava.net/jzone/articles/303979.html\n\n## jstatd\n为了使jstat,jps命令能远程监控服务器上的java服务，需要在服务器上运行jstatd服务。方式如下：\n首先新建一个文件，假设目录和文件名是 /home/jstatd.policy  文件内容如下：\n    \n    grant codebase \"file:${java.home}/../lib/tools.jar\" {  \n        permission java.security.AllPermission;  \n    };\n\n然后启动jstatd服务。\n    \n    jstatd -p 8725 -J-Djava.security.policy=/home/jstatd.policy -J-Djava.rmi.server.hostname=XX.XXX.X.XX\n\n## jstat\njstat 参数比较多，主要有以下几类：\n- 类的加载、卸载情况\n- 查看新生代、老年代和持久区的容量及使用情况\n- 查看新生代、老年代和持久区的垃圾收集情况，包括垃圾回收的次数以及垃圾回收所占用的时间\n- 查看新生代中eden区和survivor区中容量及分配情况\n\n参考：http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html\n\njstat远程监控命令：\n    \n    jstat -gcutil 18182@10.94.96.146:1099 1000\n\n## jps\n显示当前运行的java进程以及相关参数。实现原理是：读取 /tmp/hsperfdata 有几个文件，文件名是以java服务进程的ID命名的。\n\njps远程监控命令：\n    \n    jps -lv rmi://10.94.96.146:1099 1099为jstatd的端口\n\n## jvisualvm\n是一种可视化的监控工具。包括 cpu、堆、线程、类的监控，也可以分析dump的堆文件，支持类sql查询。\n\n## jconsole\n是一种可视化的监控工具。包括cpu、内存、线程、类的监控。\n","source":"_posts/jdk_tools.md","raw":"title: jdk内置工具的使用\ncategories: java\ntags: java\n---\n\njdk内置工具对于查看监控java服务的运行情况、服务的性能问题分析十分有用。对于某些监控工具的运行，需要在服务器端配置参数，来方便客户端连接。\n<!--more-->\n# 设置远程监控的相关选项\n需要在server.sh启动脚本中加入以下参数：\n- 开启JVM远程监控 -Dcom.sun.management.jmxremote=true\n- 监控的IP地址 -Djava.rmi.server.hostname=192.168.91.166，远程进程所在主机的IP。\n- 监控的端口 -Dcom.sun.management.jmxremote.port=50013，这个端口值可以任意设置，但在之后用Jconsole连接这个远程进程的时候，远程进程中的port一定要和此处的设置一致，并且一定要和远程进程的服务端口区分开。\n- 是否禁用ssl验证 -Dcom.sun.management.jmxremote.ssl，false为禁用，true为启用。\n- 是否需要用户密码验证 -Dcom.sun.management.jmxremote.authenticate，false为不需要验证，true为需要验证。\n\n# jdk 内置工具介绍\n## jinfo\njinfo pid 查看进程的java系统参数以及vm参数.\n\n## jmap\n主要是查看堆的情况，也可以将堆信息dump下来。\n### jmap -heap pid \n查看java堆的使用情况\n\n```\nAttaching to process ID 6196, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.91-b14\n\nusing thread-local object allocation.\nParallel GC with 2 thread(s)\n\nHeap Configuration:\nMinHeapFreeRatio         = 0                    ＃-xx:MinHeapFreeRatio 设置jvm堆最小空闲比率\nMaxHeapFreeRatio         = 100                  #-xx:MaxHeapFreeRatio 设置jvm堆最大空闲比率\nMaxHeapSize              = 536870912 (512.0MB)  ＃设置jvm堆的最大大小\nNewSize                  = 89128960 (85.0MB)    ＃设置jvm堆的 新生代的默认大小\nMaxNewSize               = 178782208 (170.5MB)  ＃设置jvm堆的 新生代的最大大小\nOldSize                  = 179306496 (171.0MB)  ＃设置jvm堆的 老年代的大小\nNewRatio                 = 2                    ＃设置新生代和老年代的大小比例\nSurvivorRatio            = 8                    ＃设置新生代中的 eden区和survivor区的大小比值\nMetaspaceSize            = 21807104 (20.796875MB)＃jdk1.8，类似于jdk1.7中的 permsize\nCompressedClassSpaceSize = 1073741824 (1024.0MB) \nMaxMetaspaceSize         = 17592186044415 MB\nG1HeapRegionSize         = 0 (0.0MB)\n\nHeap Usage:\nPS Young Generation\nEden Space:\ncapacity = 82837504 (79.0MB)\nused     = 27614056 (26.334815979003906MB)\nfree     = 55223448 (52.665184020996094MB)\n33.33521010000494% used\nFrom Space:\ncapacity = 3145728 (3.0MB)\nused     = 1534048 (1.462982177734375MB)\nfree     = 1611680 (1.537017822265625MB)\n48.766072591145836% used\n                                                            \nTo Space:\ncapacity = 3145728 (3.0MB)\nused     = 0 (0.0MB)\nfree     = 3145728 (3.0MB)\n0.0% used\nPS Old Generation\ncapacity = 201850880 (192.5MB)\nused     = 49296248 (47.01256561279297MB)\nfree     = 152554632 (145.48743438720703MB)\n24.422112006645698% used\n\n26112 interned Strings occupying 2975608 bytes.\n```\n\n### jmap -histo pid \n查看堆内存中对象数量和大小\n对比：jmap -histo:live pid jvm会先出发gc，再进行统计\n\n```\nnum     #instances      #bytes  class name\n----------------------------------------------\n1:         52843       25434824  [B\n2:        204331       23624576  [C\n3:         26098        7198896  [I\n4:        116142        4724056  [Ljava.lang.Object;\n5:        161108        3866592  java.lang.String\n6:         27160        2390080  java.lang.reflect.Method\n7:         47005        1504160  java.io.ObjectStreamClass$WeakClassKey\n8:         45639        1460448  java.util.HashMap$Node\n9:         12598        1443432  [Ljava.util.HashMap$Node;\n10:        24589        1180272  java.util.HashMap\n```\n\n### jmap -dump:format=b,file=heapdump pid\n将当前内存使用的详细信息存储到文件中\n\n## jstack\n打印线程的栈信息\n参考：http://www.blogjava.net/jzone/articles/303979.html\n\n## jstatd\n为了使jstat,jps命令能远程监控服务器上的java服务，需要在服务器上运行jstatd服务。方式如下：\n首先新建一个文件，假设目录和文件名是 /home/jstatd.policy  文件内容如下：\n    \n    grant codebase \"file:${java.home}/../lib/tools.jar\" {  \n        permission java.security.AllPermission;  \n    };\n\n然后启动jstatd服务。\n    \n    jstatd -p 8725 -J-Djava.security.policy=/home/jstatd.policy -J-Djava.rmi.server.hostname=XX.XXX.X.XX\n\n## jstat\njstat 参数比较多，主要有以下几类：\n- 类的加载、卸载情况\n- 查看新生代、老年代和持久区的容量及使用情况\n- 查看新生代、老年代和持久区的垃圾收集情况，包括垃圾回收的次数以及垃圾回收所占用的时间\n- 查看新生代中eden区和survivor区中容量及分配情况\n\n参考：http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html\n\njstat远程监控命令：\n    \n    jstat -gcutil 18182@10.94.96.146:1099 1000\n\n## jps\n显示当前运行的java进程以及相关参数。实现原理是：读取 /tmp/hsperfdata 有几个文件，文件名是以java服务进程的ID命名的。\n\njps远程监控命令：\n    \n    jps -lv rmi://10.94.96.146:1099 1099为jstatd的端口\n\n## jvisualvm\n是一种可视化的监控工具。包括 cpu、堆、线程、类的监控，也可以分析dump的堆文件，支持类sql查询。\n\n## jconsole\n是一种可视化的监控工具。包括cpu、内存、线程、类的监控。\n","slug":"jdk_tools","published":1,"date":"2016-07-19T02:28:39.000Z","updated":"2016-07-19T03:31:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2dx000b33fykbxot2ht","content":"<p>jdk内置工具对于查看监控java服务的运行情况、服务的性能问题分析十分有用。对于某些监控工具的运行，需要在服务器端配置参数，来方便客户端连接。<br><a id=\"more\"></a></p>\n<h1 id=\"设置远程监控的相关选项\"><a href=\"#设置远程监控的相关选项\" class=\"headerlink\" title=\"设置远程监控的相关选项\"></a>设置远程监控的相关选项</h1><p>需要在server.sh启动脚本中加入以下参数：</p>\n<ul>\n<li>开启JVM远程监控 -Dcom.sun.management.jmxremote=true</li>\n<li>监控的IP地址 -Djava.rmi.server.hostname=192.168.91.166，远程进程所在主机的IP。</li>\n<li>监控的端口 -Dcom.sun.management.jmxremote.port=50013，这个端口值可以任意设置，但在之后用Jconsole连接这个远程进程的时候，远程进程中的port一定要和此处的设置一致，并且一定要和远程进程的服务端口区分开。</li>\n<li>是否禁用ssl验证 -Dcom.sun.management.jmxremote.ssl，false为禁用，true为启用。</li>\n<li>是否需要用户密码验证 -Dcom.sun.management.jmxremote.authenticate，false为不需要验证，true为需要验证。</li>\n</ul>\n<h1 id=\"jdk-内置工具介绍\"><a href=\"#jdk-内置工具介绍\" class=\"headerlink\" title=\"jdk 内置工具介绍\"></a>jdk 内置工具介绍</h1><h2 id=\"jinfo\"><a href=\"#jinfo\" class=\"headerlink\" title=\"jinfo\"></a>jinfo</h2><p>jinfo pid 查看进程的java系统参数以及vm参数.</p>\n<h2 id=\"jmap\"><a href=\"#jmap\" class=\"headerlink\" title=\"jmap\"></a>jmap</h2><p>主要是查看堆的情况，也可以将堆信息dump下来。</p>\n<h3 id=\"jmap-heap-pid\"><a href=\"#jmap-heap-pid\" class=\"headerlink\" title=\"jmap -heap pid\"></a>jmap -heap pid</h3><p>查看java堆的使用情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Attaching to process ID 6196, please wait...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is 25.91-b14</span><br><span class=\"line\"></span><br><span class=\"line\">using thread-local object allocation.</span><br><span class=\"line\">Parallel GC with 2 thread(s)</span><br><span class=\"line\"></span><br><span class=\"line\">Heap Configuration:</span><br><span class=\"line\">MinHeapFreeRatio         = 0                    ＃-xx:MinHeapFreeRatio 设置jvm堆最小空闲比率</span><br><span class=\"line\">MaxHeapFreeRatio         = 100                  #-xx:MaxHeapFreeRatio 设置jvm堆最大空闲比率</span><br><span class=\"line\">MaxHeapSize              = 536870912 (512.0MB)  ＃设置jvm堆的最大大小</span><br><span class=\"line\">NewSize                  = 89128960 (85.0MB)    ＃设置jvm堆的 新生代的默认大小</span><br><span class=\"line\">MaxNewSize               = 178782208 (170.5MB)  ＃设置jvm堆的 新生代的最大大小</span><br><span class=\"line\">OldSize                  = 179306496 (171.0MB)  ＃设置jvm堆的 老年代的大小</span><br><span class=\"line\">NewRatio                 = 2                    ＃设置新生代和老年代的大小比例</span><br><span class=\"line\">SurvivorRatio            = 8                    ＃设置新生代中的 eden区和survivor区的大小比值</span><br><span class=\"line\">MetaspaceSize            = 21807104 (20.796875MB)＃jdk1.8，类似于jdk1.7中的 permsize</span><br><span class=\"line\">CompressedClassSpaceSize = 1073741824 (1024.0MB) </span><br><span class=\"line\">MaxMetaspaceSize         = 17592186044415 MB</span><br><span class=\"line\">G1HeapRegionSize         = 0 (0.0MB)</span><br><span class=\"line\"></span><br><span class=\"line\">Heap Usage:</span><br><span class=\"line\">PS Young Generation</span><br><span class=\"line\">Eden Space:</span><br><span class=\"line\">capacity = 82837504 (79.0MB)</span><br><span class=\"line\">used     = 27614056 (26.334815979003906MB)</span><br><span class=\"line\">free     = 55223448 (52.665184020996094MB)</span><br><span class=\"line\">33.33521010000494% used</span><br><span class=\"line\">From Space:</span><br><span class=\"line\">capacity = 3145728 (3.0MB)</span><br><span class=\"line\">used     = 1534048 (1.462982177734375MB)</span><br><span class=\"line\">free     = 1611680 (1.537017822265625MB)</span><br><span class=\"line\">48.766072591145836% used</span><br><span class=\"line\">                                                            </span><br><span class=\"line\">To Space:</span><br><span class=\"line\">capacity = 3145728 (3.0MB)</span><br><span class=\"line\">used     = 0 (0.0MB)</span><br><span class=\"line\">free     = 3145728 (3.0MB)</span><br><span class=\"line\">0.0% used</span><br><span class=\"line\">PS Old Generation</span><br><span class=\"line\">capacity = 201850880 (192.5MB)</span><br><span class=\"line\">used     = 49296248 (47.01256561279297MB)</span><br><span class=\"line\">free     = 152554632 (145.48743438720703MB)</span><br><span class=\"line\">24.422112006645698% used</span><br><span class=\"line\"></span><br><span class=\"line\">26112 interned Strings occupying 2975608 bytes.</span><br></pre></td></tr></table></figure>\n<h3 id=\"jmap-histo-pid\"><a href=\"#jmap-histo-pid\" class=\"headerlink\" title=\"jmap -histo pid\"></a>jmap -histo pid</h3><p>查看堆内存中对象数量和大小<br>对比：jmap -histo:live pid jvm会先出发gc，再进行统计</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num     #instances      #bytes  class name</span><br><span class=\"line\">----------------------------------------------</span><br><span class=\"line\">1:         52843       25434824  [B</span><br><span class=\"line\">2:        204331       23624576  [C</span><br><span class=\"line\">3:         26098        7198896  [I</span><br><span class=\"line\">4:        116142        4724056  [Ljava.lang.Object;</span><br><span class=\"line\">5:        161108        3866592  java.lang.String</span><br><span class=\"line\">6:         27160        2390080  java.lang.reflect.Method</span><br><span class=\"line\">7:         47005        1504160  java.io.ObjectStreamClass$WeakClassKey</span><br><span class=\"line\">8:         45639        1460448  java.util.HashMap$Node</span><br><span class=\"line\">9:         12598        1443432  [Ljava.util.HashMap$Node;</span><br><span class=\"line\">10:        24589        1180272  java.util.HashMap</span><br></pre></td></tr></table></figure>\n<h3 id=\"jmap-dump-format-b-file-heapdump-pid\"><a href=\"#jmap-dump-format-b-file-heapdump-pid\" class=\"headerlink\" title=\"jmap -dump:format=b,file=heapdump pid\"></a>jmap -dump:format=b,file=heapdump pid</h3><p>将当前内存使用的详细信息存储到文件中</p>\n<h2 id=\"jstack\"><a href=\"#jstack\" class=\"headerlink\" title=\"jstack\"></a>jstack</h2><p>打印线程的栈信息<br>参考：<a href=\"http://www.blogjava.net/jzone/articles/303979.html\" target=\"_blank\" rel=\"external\">http://www.blogjava.net/jzone/articles/303979.html</a></p>\n<h2 id=\"jstatd\"><a href=\"#jstatd\" class=\"headerlink\" title=\"jstatd\"></a>jstatd</h2><p>为了使jstat,jps命令能远程监控服务器上的java服务，需要在服务器上运行jstatd服务。方式如下：<br>首先新建一个文件，假设目录和文件名是 /home/jstatd.policy  文件内容如下：</p>\n<pre><code>grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {  \n    permission java.security.AllPermission;  \n};\n</code></pre><p>然后启动jstatd服务。</p>\n<pre><code>jstatd -p 8725 -J-Djava.security.policy=/home/jstatd.policy -J-Djava.rmi.server.hostname=XX.XXX.X.XX\n</code></pre><h2 id=\"jstat\"><a href=\"#jstat\" class=\"headerlink\" title=\"jstat\"></a>jstat</h2><p>jstat 参数比较多，主要有以下几类：</p>\n<ul>\n<li>类的加载、卸载情况</li>\n<li>查看新生代、老年代和持久区的容量及使用情况</li>\n<li>查看新生代、老年代和持久区的垃圾收集情况，包括垃圾回收的次数以及垃圾回收所占用的时间</li>\n<li>查看新生代中eden区和survivor区中容量及分配情况</li>\n</ul>\n<p>参考：<a href=\"http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html\" target=\"_blank\" rel=\"external\">http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html</a></p>\n<p>jstat远程监控命令：</p>\n<pre><code>jstat -gcutil 18182@10.94.96.146:1099 1000\n</code></pre><h2 id=\"jps\"><a href=\"#jps\" class=\"headerlink\" title=\"jps\"></a>jps</h2><p>显示当前运行的java进程以及相关参数。实现原理是：读取 /tmp/hsperfdata 有几个文件，文件名是以java服务进程的ID命名的。</p>\n<p>jps远程监控命令：</p>\n<pre><code>jps -lv rmi://10.94.96.146:1099 1099为jstatd的端口\n</code></pre><h2 id=\"jvisualvm\"><a href=\"#jvisualvm\" class=\"headerlink\" title=\"jvisualvm\"></a>jvisualvm</h2><p>是一种可视化的监控工具。包括 cpu、堆、线程、类的监控，也可以分析dump的堆文件，支持类sql查询。</p>\n<h2 id=\"jconsole\"><a href=\"#jconsole\" class=\"headerlink\" title=\"jconsole\"></a>jconsole</h2><p>是一种可视化的监控工具。包括cpu、内存、线程、类的监控。</p>\n","excerpt":"<p>jdk内置工具对于查看监控java服务的运行情况、服务的性能问题分析十分有用。对于某些监控工具的运行，需要在服务器端配置参数，来方便客户端连接。<br>","more":"</p>\n<h1 id=\"设置远程监控的相关选项\"><a href=\"#设置远程监控的相关选项\" class=\"headerlink\" title=\"设置远程监控的相关选项\"></a>设置远程监控的相关选项</h1><p>需要在server.sh启动脚本中加入以下参数：</p>\n<ul>\n<li>开启JVM远程监控 -Dcom.sun.management.jmxremote=true</li>\n<li>监控的IP地址 -Djava.rmi.server.hostname=192.168.91.166，远程进程所在主机的IP。</li>\n<li>监控的端口 -Dcom.sun.management.jmxremote.port=50013，这个端口值可以任意设置，但在之后用Jconsole连接这个远程进程的时候，远程进程中的port一定要和此处的设置一致，并且一定要和远程进程的服务端口区分开。</li>\n<li>是否禁用ssl验证 -Dcom.sun.management.jmxremote.ssl，false为禁用，true为启用。</li>\n<li>是否需要用户密码验证 -Dcom.sun.management.jmxremote.authenticate，false为不需要验证，true为需要验证。</li>\n</ul>\n<h1 id=\"jdk-内置工具介绍\"><a href=\"#jdk-内置工具介绍\" class=\"headerlink\" title=\"jdk 内置工具介绍\"></a>jdk 内置工具介绍</h1><h2 id=\"jinfo\"><a href=\"#jinfo\" class=\"headerlink\" title=\"jinfo\"></a>jinfo</h2><p>jinfo pid 查看进程的java系统参数以及vm参数.</p>\n<h2 id=\"jmap\"><a href=\"#jmap\" class=\"headerlink\" title=\"jmap\"></a>jmap</h2><p>主要是查看堆的情况，也可以将堆信息dump下来。</p>\n<h3 id=\"jmap-heap-pid\"><a href=\"#jmap-heap-pid\" class=\"headerlink\" title=\"jmap -heap pid\"></a>jmap -heap pid</h3><p>查看java堆的使用情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Attaching to process ID 6196, please wait...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is 25.91-b14</span><br><span class=\"line\"></span><br><span class=\"line\">using thread-local object allocation.</span><br><span class=\"line\">Parallel GC with 2 thread(s)</span><br><span class=\"line\"></span><br><span class=\"line\">Heap Configuration:</span><br><span class=\"line\">MinHeapFreeRatio         = 0                    ＃-xx:MinHeapFreeRatio 设置jvm堆最小空闲比率</span><br><span class=\"line\">MaxHeapFreeRatio         = 100                  #-xx:MaxHeapFreeRatio 设置jvm堆最大空闲比率</span><br><span class=\"line\">MaxHeapSize              = 536870912 (512.0MB)  ＃设置jvm堆的最大大小</span><br><span class=\"line\">NewSize                  = 89128960 (85.0MB)    ＃设置jvm堆的 新生代的默认大小</span><br><span class=\"line\">MaxNewSize               = 178782208 (170.5MB)  ＃设置jvm堆的 新生代的最大大小</span><br><span class=\"line\">OldSize                  = 179306496 (171.0MB)  ＃设置jvm堆的 老年代的大小</span><br><span class=\"line\">NewRatio                 = 2                    ＃设置新生代和老年代的大小比例</span><br><span class=\"line\">SurvivorRatio            = 8                    ＃设置新生代中的 eden区和survivor区的大小比值</span><br><span class=\"line\">MetaspaceSize            = 21807104 (20.796875MB)＃jdk1.8，类似于jdk1.7中的 permsize</span><br><span class=\"line\">CompressedClassSpaceSize = 1073741824 (1024.0MB) </span><br><span class=\"line\">MaxMetaspaceSize         = 17592186044415 MB</span><br><span class=\"line\">G1HeapRegionSize         = 0 (0.0MB)</span><br><span class=\"line\"></span><br><span class=\"line\">Heap Usage:</span><br><span class=\"line\">PS Young Generation</span><br><span class=\"line\">Eden Space:</span><br><span class=\"line\">capacity = 82837504 (79.0MB)</span><br><span class=\"line\">used     = 27614056 (26.334815979003906MB)</span><br><span class=\"line\">free     = 55223448 (52.665184020996094MB)</span><br><span class=\"line\">33.33521010000494% used</span><br><span class=\"line\">From Space:</span><br><span class=\"line\">capacity = 3145728 (3.0MB)</span><br><span class=\"line\">used     = 1534048 (1.462982177734375MB)</span><br><span class=\"line\">free     = 1611680 (1.537017822265625MB)</span><br><span class=\"line\">48.766072591145836% used</span><br><span class=\"line\">                                                            </span><br><span class=\"line\">To Space:</span><br><span class=\"line\">capacity = 3145728 (3.0MB)</span><br><span class=\"line\">used     = 0 (0.0MB)</span><br><span class=\"line\">free     = 3145728 (3.0MB)</span><br><span class=\"line\">0.0% used</span><br><span class=\"line\">PS Old Generation</span><br><span class=\"line\">capacity = 201850880 (192.5MB)</span><br><span class=\"line\">used     = 49296248 (47.01256561279297MB)</span><br><span class=\"line\">free     = 152554632 (145.48743438720703MB)</span><br><span class=\"line\">24.422112006645698% used</span><br><span class=\"line\"></span><br><span class=\"line\">26112 interned Strings occupying 2975608 bytes.</span><br></pre></td></tr></table></figure>\n<h3 id=\"jmap-histo-pid\"><a href=\"#jmap-histo-pid\" class=\"headerlink\" title=\"jmap -histo pid\"></a>jmap -histo pid</h3><p>查看堆内存中对象数量和大小<br>对比：jmap -histo:live pid jvm会先出发gc，再进行统计</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num     #instances      #bytes  class name</span><br><span class=\"line\">----------------------------------------------</span><br><span class=\"line\">1:         52843       25434824  [B</span><br><span class=\"line\">2:        204331       23624576  [C</span><br><span class=\"line\">3:         26098        7198896  [I</span><br><span class=\"line\">4:        116142        4724056  [Ljava.lang.Object;</span><br><span class=\"line\">5:        161108        3866592  java.lang.String</span><br><span class=\"line\">6:         27160        2390080  java.lang.reflect.Method</span><br><span class=\"line\">7:         47005        1504160  java.io.ObjectStreamClass$WeakClassKey</span><br><span class=\"line\">8:         45639        1460448  java.util.HashMap$Node</span><br><span class=\"line\">9:         12598        1443432  [Ljava.util.HashMap$Node;</span><br><span class=\"line\">10:        24589        1180272  java.util.HashMap</span><br></pre></td></tr></table></figure>\n<h3 id=\"jmap-dump-format-b-file-heapdump-pid\"><a href=\"#jmap-dump-format-b-file-heapdump-pid\" class=\"headerlink\" title=\"jmap -dump:format=b,file=heapdump pid\"></a>jmap -dump:format=b,file=heapdump pid</h3><p>将当前内存使用的详细信息存储到文件中</p>\n<h2 id=\"jstack\"><a href=\"#jstack\" class=\"headerlink\" title=\"jstack\"></a>jstack</h2><p>打印线程的栈信息<br>参考：<a href=\"http://www.blogjava.net/jzone/articles/303979.html\">http://www.blogjava.net/jzone/articles/303979.html</a></p>\n<h2 id=\"jstatd\"><a href=\"#jstatd\" class=\"headerlink\" title=\"jstatd\"></a>jstatd</h2><p>为了使jstat,jps命令能远程监控服务器上的java服务，需要在服务器上运行jstatd服务。方式如下：<br>首先新建一个文件，假设目录和文件名是 /home/jstatd.policy  文件内容如下：</p>\n<pre><code>grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {  \n    permission java.security.AllPermission;  \n};\n</code></pre><p>然后启动jstatd服务。</p>\n<pre><code>jstatd -p 8725 -J-Djava.security.policy=/home/jstatd.policy -J-Djava.rmi.server.hostname=XX.XXX.X.XX\n</code></pre><h2 id=\"jstat\"><a href=\"#jstat\" class=\"headerlink\" title=\"jstat\"></a>jstat</h2><p>jstat 参数比较多，主要有以下几类：</p>\n<ul>\n<li>类的加载、卸载情况</li>\n<li>查看新生代、老年代和持久区的容量及使用情况</li>\n<li>查看新生代、老年代和持久区的垃圾收集情况，包括垃圾回收的次数以及垃圾回收所占用的时间</li>\n<li>查看新生代中eden区和survivor区中容量及分配情况</li>\n</ul>\n<p>参考：<a href=\"http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html\">http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html</a></p>\n<p>jstat远程监控命令：</p>\n<pre><code>jstat -gcutil 18182@10.94.96.146:1099 1000\n</code></pre><h2 id=\"jps\"><a href=\"#jps\" class=\"headerlink\" title=\"jps\"></a>jps</h2><p>显示当前运行的java进程以及相关参数。实现原理是：读取 /tmp/hsperfdata 有几个文件，文件名是以java服务进程的ID命名的。</p>\n<p>jps远程监控命令：</p>\n<pre><code>jps -lv rmi://10.94.96.146:1099 1099为jstatd的端口\n</code></pre><h2 id=\"jvisualvm\"><a href=\"#jvisualvm\" class=\"headerlink\" title=\"jvisualvm\"></a>jvisualvm</h2><p>是一种可视化的监控工具。包括 cpu、堆、线程、类的监控，也可以分析dump的堆文件，支持类sql查询。</p>\n<h2 id=\"jconsole\"><a href=\"#jconsole\" class=\"headerlink\" title=\"jconsole\"></a>jconsole</h2><p>是一种可视化的监控工具。包括cpu、内存、线程、类的监控。</p>"},{"title":"linux服务器运行状态监控命令","_content":"监控linux服务器运行状态的命令主要有：vmstat、iostat、top。\n<!--more-->\n# vmstat\n可以统计cpu、内存使用情况、swap使用情况。\n```\nprocs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 251000 198692 408416    0    0     0     2    2    1  0  0 100  0  0\n 0  0      0  251000 198692 408444    0    0     0     0  113  191  1  0 100  0  0\n 0  0      0 251000 198692 408444    0    0     0     0  111  192  0  0 100  0  0\n```\n各列意义：\n\n|   分类  | 具体参数意义\n|---------|-----------------------------------------------\n|  procs  | r:等待运行的进程数\n|         | b:处在非中断睡眠状态的进程数\n| Memory  | swpd:虚拟内存的使用情况，KB\n|         | free:空闲的内存\n|         | buff:被用来作为缓存的内存数\n|  Swap   | si:从磁盘交换到内存的交换页数量 单位：KB/秒\n|         | so:从内存交换到磁盘的交换页数量，单位：KB/秒\n|   IO    | bi:发送到块设备的块数，单位：块/秒\n|         | bo:从块设备接收到的块数\n| System  | in:每秒的中断数，包括时钟中断\n|         | cs:每秒的上下文切换次数\n|   CPU   | us:用户CPU使用时间\n|         | sy:内核CPU系统使用时间\n|         | id:空闲时间\n\n# iostat\n用来查看io的状态数据。\n## iostat -d -k 1 10\n查看系统的tps和吞吐量信息。（tps：每秒的传输次数。一次传输指的是一次io请求）\n\n```\nDevice:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nvda               0.52         0.72         3.85    3527291   18852416\n\nDevice:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nvda               0.00         0.00         0.00          0          0\n```\nKB_read/s:每秒从设备读取的数据量; KB_wrtn/s:每秒向设备写入的数据量;\nKB_read:读取的总的数据量; KB_wrtn/s:写入的总的数据量;\n\n## iostat -d -x -k 1 10\n-x参数显示更多的信息\n```\nDevice:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util\nvda               0.01     0.47    0.03    0.50     0.72     3.85    17.45     0.00    1.05   0.58   0.03\n\nDevice:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util\nvda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00\n```\nrrqms/s:每秒设备相关的读取请求有多少被merge了; r/s:每秒从设备读取的数据量\nawait:每一个io请求平均处理时间; %util:在统计时间内所有处理io时间，除以总共统计时间;\n\n## iostat -c 1 10\n查看cpu的信息\n\n```\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n           0.07    0.00    0.07    0.01    0.00   99.85\n```\n\n# top\ntop提供系统的整体性能。包括cpu、内存和进程的信息。\n\n```\ntop - 16:29:18  up 56 days, 19:21,  1 user,  load average: 0.00, 0.00, 0.00\nTasks: 104 total,   1 running, 103 sleeping,   0 stopped,   0 zombie\nCpu(s):  0.2%us,  0.0%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.2%hi,  0.0%si,  0.0%st\nMem:   2017468k total,  1760404k used,   257064k free,   199192k buffers\nSwap:        0k total,        0k used,        0k free,   409536k cached\n\nPID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM  TIME+  COMMAND                                                                   \n18182 root    20   0 3017m 388m  13m S  0.3 19.7  3:38.77 java       \n```\n输出参数说明：（从上到下从左到右）\ntop： 系统当前时间， 从系统开机到现在运行了多长时间，多少用户在线，cpu负载：1分钟，5分钟，15分钟的cpu负载率\ntasks：总共104，1个运行，103休眠，0个停止，0个僵尸\ncpu：用户态进程占用cpu时间百分比，内核占用cpu时间百分比，nice（优先级）值为负的任务的用户态进程的cpu时间百分比，空闲cpu，等待io占cpu时间百分比，cpu硬中断百分比，cpu软中断百分比，st（。。。）。\nmem：总共内存，使用内存，剩余内存，用作缓存的内存\nswap：同上\n\n进程信息参数说明：\n进程号，用户，优先级（越小越优先被执行），NI（nice值，正值表示低优先级，负值表示高优先级），进程占用的虚拟内存（单位kb，virt=swap+res），进程使用的、未被换出的物理内存(单位kb，res=code+data)，进程使用的共享内存，S（进程的状态，S:休眠，R:运行，Z:僵死，N:进程优先级为负值），进程占cpu得使用率，进程使用的物理内存和总内存的百分比，该线程启动后占用的总的cpu时间，进程启动命令名称。\n","source":"_posts/linux_performance_monitoring.md","raw":"title: linux服务器运行状态监控命令\ncategories: linux\ntags: linux\n\n---\n监控linux服务器运行状态的命令主要有：vmstat、iostat、top。\n<!--more-->\n# vmstat\n可以统计cpu、内存使用情况、swap使用情况。\n```\nprocs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 251000 198692 408416    0    0     0     2    2    1  0  0 100  0  0\n 0  0      0  251000 198692 408444    0    0     0     0  113  191  1  0 100  0  0\n 0  0      0 251000 198692 408444    0    0     0     0  111  192  0  0 100  0  0\n```\n各列意义：\n\n|   分类  | 具体参数意义\n|---------|-----------------------------------------------\n|  procs  | r:等待运行的进程数\n|         | b:处在非中断睡眠状态的进程数\n| Memory  | swpd:虚拟内存的使用情况，KB\n|         | free:空闲的内存\n|         | buff:被用来作为缓存的内存数\n|  Swap   | si:从磁盘交换到内存的交换页数量 单位：KB/秒\n|         | so:从内存交换到磁盘的交换页数量，单位：KB/秒\n|   IO    | bi:发送到块设备的块数，单位：块/秒\n|         | bo:从块设备接收到的块数\n| System  | in:每秒的中断数，包括时钟中断\n|         | cs:每秒的上下文切换次数\n|   CPU   | us:用户CPU使用时间\n|         | sy:内核CPU系统使用时间\n|         | id:空闲时间\n\n# iostat\n用来查看io的状态数据。\n## iostat -d -k 1 10\n查看系统的tps和吞吐量信息。（tps：每秒的传输次数。一次传输指的是一次io请求）\n\n```\nDevice:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nvda               0.52         0.72         3.85    3527291   18852416\n\nDevice:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nvda               0.00         0.00         0.00          0          0\n```\nKB_read/s:每秒从设备读取的数据量; KB_wrtn/s:每秒向设备写入的数据量;\nKB_read:读取的总的数据量; KB_wrtn/s:写入的总的数据量;\n\n## iostat -d -x -k 1 10\n-x参数显示更多的信息\n```\nDevice:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util\nvda               0.01     0.47    0.03    0.50     0.72     3.85    17.45     0.00    1.05   0.58   0.03\n\nDevice:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util\nvda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00\n```\nrrqms/s:每秒设备相关的读取请求有多少被merge了; r/s:每秒从设备读取的数据量\nawait:每一个io请求平均处理时间; %util:在统计时间内所有处理io时间，除以总共统计时间;\n\n## iostat -c 1 10\n查看cpu的信息\n\n```\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n           0.07    0.00    0.07    0.01    0.00   99.85\n```\n\n# top\ntop提供系统的整体性能。包括cpu、内存和进程的信息。\n\n```\ntop - 16:29:18  up 56 days, 19:21,  1 user,  load average: 0.00, 0.00, 0.00\nTasks: 104 total,   1 running, 103 sleeping,   0 stopped,   0 zombie\nCpu(s):  0.2%us,  0.0%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.2%hi,  0.0%si,  0.0%st\nMem:   2017468k total,  1760404k used,   257064k free,   199192k buffers\nSwap:        0k total,        0k used,        0k free,   409536k cached\n\nPID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM  TIME+  COMMAND                                                                   \n18182 root    20   0 3017m 388m  13m S  0.3 19.7  3:38.77 java       \n```\n输出参数说明：（从上到下从左到右）\ntop： 系统当前时间， 从系统开机到现在运行了多长时间，多少用户在线，cpu负载：1分钟，5分钟，15分钟的cpu负载率\ntasks：总共104，1个运行，103休眠，0个停止，0个僵尸\ncpu：用户态进程占用cpu时间百分比，内核占用cpu时间百分比，nice（优先级）值为负的任务的用户态进程的cpu时间百分比，空闲cpu，等待io占cpu时间百分比，cpu硬中断百分比，cpu软中断百分比，st（。。。）。\nmem：总共内存，使用内存，剩余内存，用作缓存的内存\nswap：同上\n\n进程信息参数说明：\n进程号，用户，优先级（越小越优先被执行），NI（nice值，正值表示低优先级，负值表示高优先级），进程占用的虚拟内存（单位kb，virt=swap+res），进程使用的、未被换出的物理内存(单位kb，res=code+data)，进程使用的共享内存，S（进程的状态，S:休眠，R:运行，Z:僵死，N:进程优先级为负值），进程占cpu得使用率，进程使用的物理内存和总内存的百分比，该线程启动后占用的总的cpu时间，进程启动命令名称。\n","slug":"linux_performance_monitoring","published":1,"date":"2016-07-19T05:50:21.000Z","updated":"2016-07-19T09:13:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2e1000e33fydh6lvc3q","content":"<p>监控linux服务器运行状态的命令主要有：vmstat、iostat、top。<br><a id=\"more\"></a></p>\n<h1 id=\"vmstat\"><a href=\"#vmstat\" class=\"headerlink\" title=\"vmstat\"></a>vmstat</h1><p>可以统计cpu、内存使用情况、swap使用情况。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----</span><br><span class=\"line\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class=\"line\"> 1  0      0 251000 198692 408416    0    0     0     2    2    1  0  0 100  0  0</span><br><span class=\"line\"> 0  0      0  251000 198692 408444    0    0     0     0  113  191  1  0 100  0  0</span><br><span class=\"line\"> 0  0      0 251000 198692 408444    0    0     0     0  111  192  0  0 100  0  0</span><br></pre></td></tr></table></figure></p>\n<p>各列意义：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>具体参数意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>procs</td>\n<td>r:等待运行的进程数</td>\n</tr>\n<tr>\n<td></td>\n<td>b:处在非中断睡眠状态的进程数</td>\n</tr>\n<tr>\n<td>Memory</td>\n<td>swpd:虚拟内存的使用情况，KB</td>\n</tr>\n<tr>\n<td></td>\n<td>free:空闲的内存</td>\n</tr>\n<tr>\n<td></td>\n<td>buff:被用来作为缓存的内存数</td>\n</tr>\n<tr>\n<td>Swap</td>\n<td>si:从磁盘交换到内存的交换页数量 单位：KB/秒</td>\n</tr>\n<tr>\n<td></td>\n<td>so:从内存交换到磁盘的交换页数量，单位：KB/秒</td>\n</tr>\n<tr>\n<td>IO</td>\n<td>bi:发送到块设备的块数，单位：块/秒</td>\n</tr>\n<tr>\n<td></td>\n<td>bo:从块设备接收到的块数</td>\n</tr>\n<tr>\n<td>System</td>\n<td>in:每秒的中断数，包括时钟中断</td>\n</tr>\n<tr>\n<td></td>\n<td>cs:每秒的上下文切换次数</td>\n</tr>\n<tr>\n<td>CPU</td>\n<td>us:用户CPU使用时间</td>\n</tr>\n<tr>\n<td></td>\n<td>sy:内核CPU系统使用时间</td>\n</tr>\n<tr>\n<td></td>\n<td>id:空闲时间</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"iostat\"><a href=\"#iostat\" class=\"headerlink\" title=\"iostat\"></a>iostat</h1><p>用来查看io的状态数据。</p>\n<h2 id=\"iostat-d-k-1-10\"><a href=\"#iostat-d-k-1-10\" class=\"headerlink\" title=\"iostat -d -k 1 10\"></a>iostat -d -k 1 10</h2><p>查看系统的tps和吞吐量信息。（tps：每秒的传输次数。一次传输指的是一次io请求）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class=\"line\">vda               0.52         0.72         3.85    3527291   18852416</span><br><span class=\"line\"></span><br><span class=\"line\">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class=\"line\">vda               0.00         0.00         0.00          0          0</span><br></pre></td></tr></table></figure>\n<p>KB_read/s:每秒从设备读取的数据量; KB_wrtn/s:每秒向设备写入的数据量;<br>KB_read:读取的总的数据量; KB_wrtn/s:写入的总的数据量;</p>\n<h2 id=\"iostat-d-x-k-1-10\"><a href=\"#iostat-d-x-k-1-10\" class=\"headerlink\" title=\"iostat -d -x -k 1 10\"></a>iostat -d -x -k 1 10</h2><p>-x参数显示更多的信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util</span><br><span class=\"line\">vda               0.01     0.47    0.03    0.50     0.72     3.85    17.45     0.00    1.05   0.58   0.03</span><br><span class=\"line\"></span><br><span class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util</span><br><span class=\"line\">vda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00</span><br></pre></td></tr></table></figure></p>\n<p>rrqms/s:每秒设备相关的读取请求有多少被merge了; r/s:每秒从设备读取的数据量<br>await:每一个io请求平均处理时间; %util:在统计时间内所有处理io时间，除以总共统计时间;</p>\n<h2 id=\"iostat-c-1-10\"><a href=\"#iostat-c-1-10\" class=\"headerlink\" title=\"iostat -c 1 10\"></a>iostat -c 1 10</h2><p>查看cpu的信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class=\"line\">           0.07    0.00    0.07    0.01    0.00   99.85</span><br></pre></td></tr></table></figure>\n<h1 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a>top</h1><p>top提供系统的整体性能。包括cpu、内存和进程的信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top - 16:29:18  up 56 days, 19:21,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class=\"line\">Tasks: 104 total,   1 running, 103 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">Cpu(s):  0.2%us,  0.0%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.2%hi,  0.0%si,  0.0%st</span><br><span class=\"line\">Mem:   2017468k total,  1760404k used,   257064k free,   199192k buffers</span><br><span class=\"line\">Swap:        0k total,        0k used,        0k free,   409536k cached</span><br><span class=\"line\"></span><br><span class=\"line\">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM  TIME+  COMMAND                                                                   </span><br><span class=\"line\">18182 root    20   0 3017m 388m  13m S  0.3 19.7  3:38.77 java</span><br></pre></td></tr></table></figure>\n<p>输出参数说明：（从上到下从左到右）<br>top： 系统当前时间， 从系统开机到现在运行了多长时间，多少用户在线，cpu负载：1分钟，5分钟，15分钟的cpu负载率<br>tasks：总共104，1个运行，103休眠，0个停止，0个僵尸<br>cpu：用户态进程占用cpu时间百分比，内核占用cpu时间百分比，nice（优先级）值为负的任务的用户态进程的cpu时间百分比，空闲cpu，等待io占cpu时间百分比，cpu硬中断百分比，cpu软中断百分比，st（。。。）。<br>mem：总共内存，使用内存，剩余内存，用作缓存的内存<br>swap：同上</p>\n<p>进程信息参数说明：<br>进程号，用户，优先级（越小越优先被执行），NI（nice值，正值表示低优先级，负值表示高优先级），进程占用的虚拟内存（单位kb，virt=swap+res），进程使用的、未被换出的物理内存(单位kb，res=code+data)，进程使用的共享内存，S（进程的状态，S:休眠，R:运行，Z:僵死，N:进程优先级为负值），进程占cpu得使用率，进程使用的物理内存和总内存的百分比，该线程启动后占用的总的cpu时间，进程启动命令名称。</p>\n","excerpt":"<p>监控linux服务器运行状态的命令主要有：vmstat、iostat、top。<br>","more":"</p>\n<h1 id=\"vmstat\"><a href=\"#vmstat\" class=\"headerlink\" title=\"vmstat\"></a>vmstat</h1><p>可以统计cpu、内存使用情况、swap使用情况。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----</span><br><span class=\"line\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class=\"line\"> 1  0      0 251000 198692 408416    0    0     0     2    2    1  0  0 100  0  0</span><br><span class=\"line\"> 0  0      0  251000 198692 408444    0    0     0     0  113  191  1  0 100  0  0</span><br><span class=\"line\"> 0  0      0 251000 198692 408444    0    0     0     0  111  192  0  0 100  0  0</span><br></pre></td></tr></table></figure></p>\n<p>各列意义：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>具体参数意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>procs</td>\n<td>r:等待运行的进程数</td>\n</tr>\n<tr>\n<td></td>\n<td>b:处在非中断睡眠状态的进程数</td>\n</tr>\n<tr>\n<td>Memory</td>\n<td>swpd:虚拟内存的使用情况，KB</td>\n</tr>\n<tr>\n<td></td>\n<td>free:空闲的内存</td>\n</tr>\n<tr>\n<td></td>\n<td>buff:被用来作为缓存的内存数</td>\n</tr>\n<tr>\n<td>Swap</td>\n<td>si:从磁盘交换到内存的交换页数量 单位：KB/秒</td>\n</tr>\n<tr>\n<td></td>\n<td>so:从内存交换到磁盘的交换页数量，单位：KB/秒</td>\n</tr>\n<tr>\n<td>IO</td>\n<td>bi:发送到块设备的块数，单位：块/秒</td>\n</tr>\n<tr>\n<td></td>\n<td>bo:从块设备接收到的块数</td>\n</tr>\n<tr>\n<td>System</td>\n<td>in:每秒的中断数，包括时钟中断</td>\n</tr>\n<tr>\n<td></td>\n<td>cs:每秒的上下文切换次数</td>\n</tr>\n<tr>\n<td>CPU</td>\n<td>us:用户CPU使用时间</td>\n</tr>\n<tr>\n<td></td>\n<td>sy:内核CPU系统使用时间</td>\n</tr>\n<tr>\n<td></td>\n<td>id:空闲时间</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"iostat\"><a href=\"#iostat\" class=\"headerlink\" title=\"iostat\"></a>iostat</h1><p>用来查看io的状态数据。</p>\n<h2 id=\"iostat-d-k-1-10\"><a href=\"#iostat-d-k-1-10\" class=\"headerlink\" title=\"iostat -d -k 1 10\"></a>iostat -d -k 1 10</h2><p>查看系统的tps和吞吐量信息。（tps：每秒的传输次数。一次传输指的是一次io请求）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class=\"line\">vda               0.52         0.72         3.85    3527291   18852416</span><br><span class=\"line\"></span><br><span class=\"line\">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class=\"line\">vda               0.00         0.00         0.00          0          0</span><br></pre></td></tr></table></figure>\n<p>KB_read/s:每秒从设备读取的数据量; KB_wrtn/s:每秒向设备写入的数据量;<br>KB_read:读取的总的数据量; KB_wrtn/s:写入的总的数据量;</p>\n<h2 id=\"iostat-d-x-k-1-10\"><a href=\"#iostat-d-x-k-1-10\" class=\"headerlink\" title=\"iostat -d -x -k 1 10\"></a>iostat -d -x -k 1 10</h2><p>-x参数显示更多的信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util</span><br><span class=\"line\">vda               0.01     0.47    0.03    0.50     0.72     3.85    17.45     0.00    1.05   0.58   0.03</span><br><span class=\"line\"></span><br><span class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util</span><br><span class=\"line\">vda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00</span><br></pre></td></tr></table></figure></p>\n<p>rrqms/s:每秒设备相关的读取请求有多少被merge了; r/s:每秒从设备读取的数据量<br>await:每一个io请求平均处理时间; %util:在统计时间内所有处理io时间，除以总共统计时间;</p>\n<h2 id=\"iostat-c-1-10\"><a href=\"#iostat-c-1-10\" class=\"headerlink\" title=\"iostat -c 1 10\"></a>iostat -c 1 10</h2><p>查看cpu的信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class=\"line\">           0.07    0.00    0.07    0.01    0.00   99.85</span><br></pre></td></tr></table></figure>\n<h1 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a>top</h1><p>top提供系统的整体性能。包括cpu、内存和进程的信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top - 16:29:18  up 56 days, 19:21,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class=\"line\">Tasks: 104 total,   1 running, 103 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">Cpu(s):  0.2%us,  0.0%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.2%hi,  0.0%si,  0.0%st</span><br><span class=\"line\">Mem:   2017468k total,  1760404k used,   257064k free,   199192k buffers</span><br><span class=\"line\">Swap:        0k total,        0k used,        0k free,   409536k cached</span><br><span class=\"line\"></span><br><span class=\"line\">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM  TIME+  COMMAND                                                                   </span><br><span class=\"line\">18182 root    20   0 3017m 388m  13m S  0.3 19.7  3:38.77 java</span><br></pre></td></tr></table></figure>\n<p>输出参数说明：（从上到下从左到右）<br>top： 系统当前时间， 从系统开机到现在运行了多长时间，多少用户在线，cpu负载：1分钟，5分钟，15分钟的cpu负载率<br>tasks：总共104，1个运行，103休眠，0个停止，0个僵尸<br>cpu：用户态进程占用cpu时间百分比，内核占用cpu时间百分比，nice（优先级）值为负的任务的用户态进程的cpu时间百分比，空闲cpu，等待io占cpu时间百分比，cpu硬中断百分比，cpu软中断百分比，st（。。。）。<br>mem：总共内存，使用内存，剩余内存，用作缓存的内存<br>swap：同上</p>\n<p>进程信息参数说明：<br>进程号，用户，优先级（越小越优先被执行），NI（nice值，正值表示低优先级，负值表示高优先级），进程占用的虚拟内存（单位kb，virt=swap+res），进程使用的、未被换出的物理内存(单位kb，res=code+data)，进程使用的共享内存，S（进程的状态，S:休眠，R:运行，Z:僵死，N:进程优先级为负值），进程占cpu得使用率，进程使用的物理内存和总内存的百分比，该线程启动后占用的总的cpu时间，进程启动命令名称。</p>"},{"title":"mysql环境搭建，备份数据以及授权访问","_content":"主要介绍了mysql环境搭建，以及mysqldump和grant命令的使用.\n<!--more-->\n### mysql环境搭建\n\n在linux环境下搭建mysql主要步骤包括：\n1. 查看是否安装过mysql：yum list installed mysql\\*\n2. 安装mysql客户端：yum -y install mysql\n3. 安装mysql服务器端：yum -y install mysql_server\n4. 安装mysql开发库：yum -y install mysql-devel\n5. 修改配置文件：vim /etc/my.cnf 添加：default-character-set=utf8\n6. 启动mysql数据库: service mysqld start\n7. 创建root密码：mysqladmin -u root password root\n\n### 备份数据\n\nmysql数据库的备份主要用的命令是 mysqldump.\n1. 备份某个数据库的所有数据 \n\n```\nmysqldump -h 10.10.40.8 -u root -p root database_name > backup.sql\nsource backup.sql\n```\n\n### 授权访问\n在多个机器访问一台机器上的数据库时，这时需要针对指定用户名情况下开放mysql的远程连接：\n1. 授权root用户使用root密码从任何主机连接到mysql服务器\n```\ngrant all privileges on *.* to 'root@%' identified by 'root' with grant option;\nflush privileges;\n```\n\n2. 授权root用户用root密码从192.10.10.1的主机连接到mysql数据库的ja数据库\n```\ngrant all privileges on ja.* to 'root@192.10.10.1' identified by 'root' with grant option;\nflush privileges;\n```\n\n3.任何主机访问数据的权限\n```\ngrant all privileges on *.* to 'root@%' with grant option;\nflush privileges;\n```\n","source":"_posts/mysql-enviroment.md","raw":"---\ntitle: mysql环境搭建，备份数据以及授权访问\ncategories: mysql\ntags: mysql\n\n---\n主要介绍了mysql环境搭建，以及mysqldump和grant命令的使用.\n<!--more-->\n### mysql环境搭建\n\n在linux环境下搭建mysql主要步骤包括：\n1. 查看是否安装过mysql：yum list installed mysql\\*\n2. 安装mysql客户端：yum -y install mysql\n3. 安装mysql服务器端：yum -y install mysql_server\n4. 安装mysql开发库：yum -y install mysql-devel\n5. 修改配置文件：vim /etc/my.cnf 添加：default-character-set=utf8\n6. 启动mysql数据库: service mysqld start\n7. 创建root密码：mysqladmin -u root password root\n\n### 备份数据\n\nmysql数据库的备份主要用的命令是 mysqldump.\n1. 备份某个数据库的所有数据 \n\n```\nmysqldump -h 10.10.40.8 -u root -p root database_name > backup.sql\nsource backup.sql\n```\n\n### 授权访问\n在多个机器访问一台机器上的数据库时，这时需要针对指定用户名情况下开放mysql的远程连接：\n1. 授权root用户使用root密码从任何主机连接到mysql服务器\n```\ngrant all privileges on *.* to 'root@%' identified by 'root' with grant option;\nflush privileges;\n```\n\n2. 授权root用户用root密码从192.10.10.1的主机连接到mysql数据库的ja数据库\n```\ngrant all privileges on ja.* to 'root@192.10.10.1' identified by 'root' with grant option;\nflush privileges;\n```\n\n3.任何主机访问数据的权限\n```\ngrant all privileges on *.* to 'root@%' with grant option;\nflush privileges;\n```\n","slug":"mysql-enviroment","published":1,"date":"2016-06-07T11:58:45.000Z","updated":"2016-06-07T12:03:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2e6000i33fyrsdwhjwx","content":"<p>主要介绍了mysql环境搭建，以及mysqldump和grant命令的使用.<br><a id=\"more\"></a></p>\n<h3 id=\"mysql环境搭建\"><a href=\"#mysql环境搭建\" class=\"headerlink\" title=\"mysql环境搭建\"></a>mysql环境搭建</h3><p>在linux环境下搭建mysql主要步骤包括：</p>\n<ol>\n<li>查看是否安装过mysql：yum list installed mysql*</li>\n<li>安装mysql客户端：yum -y install mysql</li>\n<li>安装mysql服务器端：yum -y install mysql_server</li>\n<li>安装mysql开发库：yum -y install mysql-devel</li>\n<li>修改配置文件：vim /etc/my.cnf 添加：default-character-set=utf8</li>\n<li>启动mysql数据库: service mysqld start</li>\n<li>创建root密码：mysqladmin -u root password root</li>\n</ol>\n<h3 id=\"备份数据\"><a href=\"#备份数据\" class=\"headerlink\" title=\"备份数据\"></a>备份数据</h3><p>mysql数据库的备份主要用的命令是 mysqldump.</p>\n<ol>\n<li>备份某个数据库的所有数据 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldump -h 10.10.40.8 -u root -p root database_name &gt; backup.sql</span><br><span class=\"line\">source backup.sql</span><br></pre></td></tr></table></figure>\n<h3 id=\"授权访问\"><a href=\"#授权访问\" class=\"headerlink\" title=\"授权访问\"></a>授权访问</h3><p>在多个机器访问一台机器上的数据库时，这时需要针对指定用户名情况下开放mysql的远程连接：</p>\n<ol>\n<li><p>授权root用户使用root密码从任何主机连接到mysql服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grant all privileges on *.* to &apos;root@%&apos; identified by &apos;root&apos; with grant option;</span><br><span class=\"line\">flush privileges;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>授权root用户用root密码从192.10.10.1的主机连接到mysql数据库的ja数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grant all privileges on ja.* to &apos;root@192.10.10.1&apos; identified by &apos;root&apos; with grant option;</span><br><span class=\"line\">flush privileges;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.任何主机访问数据的权限<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grant all privileges on *.* to &apos;root@%&apos; with grant option;</span><br><span class=\"line\">flush privileges;</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<p>主要介绍了mysql环境搭建，以及mysqldump和grant命令的使用.<br>","more":"</p>\n<h3 id=\"mysql环境搭建\"><a href=\"#mysql环境搭建\" class=\"headerlink\" title=\"mysql环境搭建\"></a>mysql环境搭建</h3><p>在linux环境下搭建mysql主要步骤包括：</p>\n<ol>\n<li>查看是否安装过mysql：yum list installed mysql*</li>\n<li>安装mysql客户端：yum -y install mysql</li>\n<li>安装mysql服务器端：yum -y install mysql_server</li>\n<li>安装mysql开发库：yum -y install mysql-devel</li>\n<li>修改配置文件：vim /etc/my.cnf 添加：default-character-set=utf8</li>\n<li>启动mysql数据库: service mysqld start</li>\n<li>创建root密码：mysqladmin -u root password root</li>\n</ol>\n<h3 id=\"备份数据\"><a href=\"#备份数据\" class=\"headerlink\" title=\"备份数据\"></a>备份数据</h3><p>mysql数据库的备份主要用的命令是 mysqldump.</p>\n<ol>\n<li>备份某个数据库的所有数据 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldump -h 10.10.40.8 -u root -p root database_name &gt; backup.sql</span><br><span class=\"line\">source backup.sql</span><br></pre></td></tr></table></figure>\n<h3 id=\"授权访问\"><a href=\"#授权访问\" class=\"headerlink\" title=\"授权访问\"></a>授权访问</h3><p>在多个机器访问一台机器上的数据库时，这时需要针对指定用户名情况下开放mysql的远程连接：</p>\n<ol>\n<li><p>授权root用户使用root密码从任何主机连接到mysql服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grant all privileges on *.* to &apos;root@%&apos; identified by &apos;root&apos; with grant option;</span><br><span class=\"line\">flush privileges;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>授权root用户用root密码从192.10.10.1的主机连接到mysql数据库的ja数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grant all privileges on ja.* to &apos;root@192.10.10.1&apos; identified by &apos;root&apos; with grant option;</span><br><span class=\"line\">flush privileges;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.任何主机访问数据的权限<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grant all privileges on *.* to &apos;root@%&apos; with grant option;</span><br><span class=\"line\">flush privileges;</span><br></pre></td></tr></table></figure></p>"},{"title":"jvm内存溢出的原因及解决方案介绍","_content":"内存溢出（OutOfMemory,oom）通常出现在某一内存空间块耗尽的时候。造成内存溢出的情况有：堆溢出，栈溢出，直接内存溢出,永久区溢出等。\n<!--more-->\n# 堆溢出\n## 现象\n当大量对象占用了堆空间，且都是强引用不能被回收时，如果对象大小之和大于了Xmx时，就会出现堆溢出。\n堆溢出时，会提示 java heap space\n\n## 解决方案\n1.加大Xmx的值\n2.利用visualvm工具，分析找到占用大量空间的对象，并进行优化\n\n# 直接内存溢出\n## 现象\n\n例子：\n\n    public class DirectBufferOOM {\n        public static void main(String args[]) {\n            for (int i = 0; i < 1024; i++) {\n                ByteBuffer.allocateDirect(1024*1024);\n                System.out.println(i);\n                //System.gc();\n            }\n        }\n    }\n\njvm配置如下：\n```\n-Xmx1g -XX:PrintGCDetails\n```\n上面的配置运行在jdk1.7 64位上时，不会出现问题。当运行在jdk1.7 32位上时，会出现OOM。原因是：32位系统进程的寻址空间为4G，其中2G为用户空间，2G为系统空间，所以实际可用的系统空间有2G。当java内存（堆空间、栈空间、直接内存空间、虚拟机自身所用的内存）之和大于2G时，就会出现OOM。\n\n## 解决方案\n可以设置 -XX:MaxDirectMemorySize的大小，比如512M。当直接内存达到这个值时，会出发垃圾回收。\n\n# 栈溢出\n## 现象\n创建了太多的线程。unable to create new native thread. 说明创建的线程已经饱和。\n\n## 解决方案\n1.减小堆空间\n2.减小每个线程所占用的栈空间。即减小-Xss的值。但是会增加栈溢出的风险。\n\n# 永久区溢出\n## 现象\n当永久区存储的元数据类型太多时，会出现 Permgen space. \n\n## 解决方案\n1.增加MaxPermSize\n2.减少系统需要的类的数量\n2.使用ClassLoader合理地装载各个类，并定期进行回收\n","source":"_posts/jvm-outofmemory.md","raw":"title: jvm内存溢出的原因及解决方案介绍\ncategories: java\ntags: java\n---\n内存溢出（OutOfMemory,oom）通常出现在某一内存空间块耗尽的时候。造成内存溢出的情况有：堆溢出，栈溢出，直接内存溢出,永久区溢出等。\n<!--more-->\n# 堆溢出\n## 现象\n当大量对象占用了堆空间，且都是强引用不能被回收时，如果对象大小之和大于了Xmx时，就会出现堆溢出。\n堆溢出时，会提示 java heap space\n\n## 解决方案\n1.加大Xmx的值\n2.利用visualvm工具，分析找到占用大量空间的对象，并进行优化\n\n# 直接内存溢出\n## 现象\n\n例子：\n\n    public class DirectBufferOOM {\n        public static void main(String args[]) {\n            for (int i = 0; i < 1024; i++) {\n                ByteBuffer.allocateDirect(1024*1024);\n                System.out.println(i);\n                //System.gc();\n            }\n        }\n    }\n\njvm配置如下：\n```\n-Xmx1g -XX:PrintGCDetails\n```\n上面的配置运行在jdk1.7 64位上时，不会出现问题。当运行在jdk1.7 32位上时，会出现OOM。原因是：32位系统进程的寻址空间为4G，其中2G为用户空间，2G为系统空间，所以实际可用的系统空间有2G。当java内存（堆空间、栈空间、直接内存空间、虚拟机自身所用的内存）之和大于2G时，就会出现OOM。\n\n## 解决方案\n可以设置 -XX:MaxDirectMemorySize的大小，比如512M。当直接内存达到这个值时，会出发垃圾回收。\n\n# 栈溢出\n## 现象\n创建了太多的线程。unable to create new native thread. 说明创建的线程已经饱和。\n\n## 解决方案\n1.减小堆空间\n2.减小每个线程所占用的栈空间。即减小-Xss的值。但是会增加栈溢出的风险。\n\n# 永久区溢出\n## 现象\n当永久区存储的元数据类型太多时，会出现 Permgen space. \n\n## 解决方案\n1.增加MaxPermSize\n2.减少系统需要的类的数量\n2.使用ClassLoader合理地装载各个类，并定期进行回收\n","slug":"jvm-outofmemory","published":1,"date":"2016-07-20T06:55:52.000Z","updated":"2016-07-20T06:55:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2e7000m33fykd6j2iwd","content":"<p>内存溢出（OutOfMemory,oom）通常出现在某一内存空间块耗尽的时候。造成内存溢出的情况有：堆溢出，栈溢出，直接内存溢出,永久区溢出等。<br><a id=\"more\"></a></p>\n<h1 id=\"堆溢出\"><a href=\"#堆溢出\" class=\"headerlink\" title=\"堆溢出\"></a>堆溢出</h1><h2 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>当大量对象占用了堆空间，且都是强引用不能被回收时，如果对象大小之和大于了Xmx时，就会出现堆溢出。<br>堆溢出时，会提示 java heap space</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1.加大Xmx的值<br>2.利用visualvm工具，分析找到占用大量空间的对象，并进行优化</p>\n<h1 id=\"直接内存溢出\"><a href=\"#直接内存溢出\" class=\"headerlink\" title=\"直接内存溢出\"></a>直接内存溢出</h1><h2 id=\"现象-1\"><a href=\"#现象-1\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>例子：</p>\n<pre><code>public class DirectBufferOOM {\n    public static void main(String args[]) {\n        for (int i = 0; i &lt; 1024; i++) {\n            ByteBuffer.allocateDirect(1024*1024);\n            System.out.println(i);\n            //System.gc();\n        }\n    }\n}\n</code></pre><p>jvm配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmx1g -XX:PrintGCDetails</span><br></pre></td></tr></table></figure></p>\n<p>上面的配置运行在jdk1.7 64位上时，不会出现问题。当运行在jdk1.7 32位上时，会出现OOM。原因是：32位系统进程的寻址空间为4G，其中2G为用户空间，2G为系统空间，所以实际可用的系统空间有2G。当java内存（堆空间、栈空间、直接内存空间、虚拟机自身所用的内存）之和大于2G时，就会出现OOM。</p>\n<h2 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>可以设置 -XX:MaxDirectMemorySize的大小，比如512M。当直接内存达到这个值时，会出发垃圾回收。</p>\n<h1 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a>栈溢出</h1><h2 id=\"现象-2\"><a href=\"#现象-2\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>创建了太多的线程。unable to create new native thread. 说明创建的线程已经饱和。</p>\n<h2 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1.减小堆空间<br>2.减小每个线程所占用的栈空间。即减小-Xss的值。但是会增加栈溢出的风险。</p>\n<h1 id=\"永久区溢出\"><a href=\"#永久区溢出\" class=\"headerlink\" title=\"永久区溢出\"></a>永久区溢出</h1><h2 id=\"现象-3\"><a href=\"#现象-3\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>当永久区存储的元数据类型太多时，会出现 Permgen space. </p>\n<h2 id=\"解决方案-3\"><a href=\"#解决方案-3\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1.增加MaxPermSize<br>2.减少系统需要的类的数量<br>2.使用ClassLoader合理地装载各个类，并定期进行回收</p>\n","excerpt":"<p>内存溢出（OutOfMemory,oom）通常出现在某一内存空间块耗尽的时候。造成内存溢出的情况有：堆溢出，栈溢出，直接内存溢出,永久区溢出等。<br>","more":"</p>\n<h1 id=\"堆溢出\"><a href=\"#堆溢出\" class=\"headerlink\" title=\"堆溢出\"></a>堆溢出</h1><h2 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>当大量对象占用了堆空间，且都是强引用不能被回收时，如果对象大小之和大于了Xmx时，就会出现堆溢出。<br>堆溢出时，会提示 java heap space</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1.加大Xmx的值<br>2.利用visualvm工具，分析找到占用大量空间的对象，并进行优化</p>\n<h1 id=\"直接内存溢出\"><a href=\"#直接内存溢出\" class=\"headerlink\" title=\"直接内存溢出\"></a>直接内存溢出</h1><h2 id=\"现象-1\"><a href=\"#现象-1\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>例子：</p>\n<pre><code>public class DirectBufferOOM {\n    public static void main(String args[]) {\n        for (int i = 0; i &lt; 1024; i++) {\n            ByteBuffer.allocateDirect(1024*1024);\n            System.out.println(i);\n            //System.gc();\n        }\n    }\n}\n</code></pre><p>jvm配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmx1g -XX:PrintGCDetails</span><br></pre></td></tr></table></figure></p>\n<p>上面的配置运行在jdk1.7 64位上时，不会出现问题。当运行在jdk1.7 32位上时，会出现OOM。原因是：32位系统进程的寻址空间为4G，其中2G为用户空间，2G为系统空间，所以实际可用的系统空间有2G。当java内存（堆空间、栈空间、直接内存空间、虚拟机自身所用的内存）之和大于2G时，就会出现OOM。</p>\n<h2 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>可以设置 -XX:MaxDirectMemorySize的大小，比如512M。当直接内存达到这个值时，会出发垃圾回收。</p>\n<h1 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a>栈溢出</h1><h2 id=\"现象-2\"><a href=\"#现象-2\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>创建了太多的线程。unable to create new native thread. 说明创建的线程已经饱和。</p>\n<h2 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1.减小堆空间<br>2.减小每个线程所占用的栈空间。即减小-Xss的值。但是会增加栈溢出的风险。</p>\n<h1 id=\"永久区溢出\"><a href=\"#永久区溢出\" class=\"headerlink\" title=\"永久区溢出\"></a>永久区溢出</h1><h2 id=\"现象-3\"><a href=\"#现象-3\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>当永久区存储的元数据类型太多时，会出现 Permgen space. </p>\n<h2 id=\"解决方案-3\"><a href=\"#解决方案-3\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1.增加MaxPermSize<br>2.减少系统需要的类的数量<br>2.使用ClassLoader合理地装载各个类，并定期进行回收</p>"},{"title":"字典的实现","_content":"redis字典的实现在某些地方的设计很类似于jdk中hashmap的设计，如解决冲突方面都是利用了链式法解决冲突的。在存储结构和rehash方案上，redis的hash实现明显比hashmap更有优势。\nredis字典实现：\n<!--more-->\n\n### 存储结构\n\n字典底层的存储结构图如下：\n![hash存储结构图](https://raw.githubusercontent.com/buptlsy/images/master/redis-hash.png)\n\n    typedef struct dict {\n        dictType* type; // 特定函数的类型\n        void* privdata; //特定函数的参数\n        dictht* ht; //哈希表\n        int rehashidx; //rehash进度。-1表示未开始\n    } dict;\n\n    typedef struct dictType {\n    } dictType;\n\n    typedef struct dictht {\n        unsigned long size; //哈希表大小\n        unsigned long sizemask; //掩码，用来计算位置\n        unsiged long used; //已经使用的数量\n        dictEntry **table; //哈希表数组\n    } dictht;\n\n    typedef struct dictEntry {\n        void* key; // key\n        union {\n            void *val;\n            uint64_t u64;\n            int64_t s64;\n        } v; // value\n        struct dictEntry *next; //形成链表\n    } dictEntry;\n\n### 哈希函数\n\n字典计算出每个key最终放的位置是通过：\n    \n    // 通过哈希函数计算出哈希值\n    hash = dict->type->hashFunction(key);\n    // 通过哈希值计算出最终索引的位置\n    index = hash & dict->ht[x].sizemask;\n\n哈希函数用的是：murmurhash2\n\n### 解决冲突\n\n当多个key计算出的索引值一样的话，通过拉链法解决冲突。\n\n### rehash\n\n#### 进行rehash的条件\n\n扩容：\n1. 当服务器没有执行bgsave和bgrewriteaof时，负载因子大于等于1\n2. 当服务器执行bgsave或者bgrewriteaof时，负载因子大于等于5\n(负载因子=哈希表已用大小/哈希表大小)\n\n为什么会有这样的区分？\n\n\n缩容：当负载因子小于0.1时\n\n#### rehash过程\n\n1. 确定ht[1]哈希表的大小\n如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；\n如果是缩容，那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。\n2. 将ht[0]的kv迁移到ht[1]\n利用渐进式迁移策略。\n步骤：\na. 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。\nb. 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。\nc. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。\nd. 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。\n3. 释放ht[0], 将ht[1]设置为ht[0]，并在ht[1]上申请空的哈希表\n\n","source":"_posts/redis_hash.md","raw":"---\ntitle: 字典的实现\ncategories: redis\ntags: redis\n\n---\nredis字典的实现在某些地方的设计很类似于jdk中hashmap的设计，如解决冲突方面都是利用了链式法解决冲突的。在存储结构和rehash方案上，redis的hash实现明显比hashmap更有优势。\nredis字典实现：\n<!--more-->\n\n### 存储结构\n\n字典底层的存储结构图如下：\n![hash存储结构图](https://raw.githubusercontent.com/buptlsy/images/master/redis-hash.png)\n\n    typedef struct dict {\n        dictType* type; // 特定函数的类型\n        void* privdata; //特定函数的参数\n        dictht* ht; //哈希表\n        int rehashidx; //rehash进度。-1表示未开始\n    } dict;\n\n    typedef struct dictType {\n    } dictType;\n\n    typedef struct dictht {\n        unsigned long size; //哈希表大小\n        unsigned long sizemask; //掩码，用来计算位置\n        unsiged long used; //已经使用的数量\n        dictEntry **table; //哈希表数组\n    } dictht;\n\n    typedef struct dictEntry {\n        void* key; // key\n        union {\n            void *val;\n            uint64_t u64;\n            int64_t s64;\n        } v; // value\n        struct dictEntry *next; //形成链表\n    } dictEntry;\n\n### 哈希函数\n\n字典计算出每个key最终放的位置是通过：\n    \n    // 通过哈希函数计算出哈希值\n    hash = dict->type->hashFunction(key);\n    // 通过哈希值计算出最终索引的位置\n    index = hash & dict->ht[x].sizemask;\n\n哈希函数用的是：murmurhash2\n\n### 解决冲突\n\n当多个key计算出的索引值一样的话，通过拉链法解决冲突。\n\n### rehash\n\n#### 进行rehash的条件\n\n扩容：\n1. 当服务器没有执行bgsave和bgrewriteaof时，负载因子大于等于1\n2. 当服务器执行bgsave或者bgrewriteaof时，负载因子大于等于5\n(负载因子=哈希表已用大小/哈希表大小)\n\n为什么会有这样的区分？\n\n\n缩容：当负载因子小于0.1时\n\n#### rehash过程\n\n1. 确定ht[1]哈希表的大小\n如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；\n如果是缩容，那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。\n2. 将ht[0]的kv迁移到ht[1]\n利用渐进式迁移策略。\n步骤：\na. 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。\nb. 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。\nc. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。\nd. 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。\n3. 释放ht[0], 将ht[1]设置为ht[0]，并在ht[1]上申请空的哈希表\n\n","slug":"redis_hash","published":1,"date":"2016-06-13T05:42:40.000Z","updated":"2016-06-13T05:47:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2e9000p33fy460ivdr8","content":"<p>redis字典的实现在某些地方的设计很类似于jdk中hashmap的设计，如解决冲突方面都是利用了链式法解决冲突的。在存储结构和rehash方案上，redis的hash实现明显比hashmap更有优势。<br>redis字典实现：<br><a id=\"more\"></a></p>\n<h3 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h3><p>字典底层的存储结构图如下：<br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/redis-hash.png\" alt=\"hash存储结构图\"></p>\n<pre><code>typedef struct dict {\n    dictType* type; // 特定函数的类型\n    void* privdata; //特定函数的参数\n    dictht* ht; //哈希表\n    int rehashidx; //rehash进度。-1表示未开始\n} dict;\n\ntypedef struct dictType {\n} dictType;\n\ntypedef struct dictht {\n    unsigned long size; //哈希表大小\n    unsigned long sizemask; //掩码，用来计算位置\n    unsiged long used; //已经使用的数量\n    dictEntry **table; //哈希表数组\n} dictht;\n\ntypedef struct dictEntry {\n    void* key; // key\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v; // value\n    struct dictEntry *next; //形成链表\n} dictEntry;\n</code></pre><h3 id=\"哈希函数\"><a href=\"#哈希函数\" class=\"headerlink\" title=\"哈希函数\"></a>哈希函数</h3><p>字典计算出每个key最终放的位置是通过：</p>\n<pre><code>// 通过哈希函数计算出哈希值\nhash = dict-&gt;type-&gt;hashFunction(key);\n// 通过哈希值计算出最终索引的位置\nindex = hash &amp; dict-&gt;ht[x].sizemask;\n</code></pre><p>哈希函数用的是：murmurhash2</p>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><p>当多个key计算出的索引值一样的话，通过拉链法解决冲突。</p>\n<h3 id=\"rehash\"><a href=\"#rehash\" class=\"headerlink\" title=\"rehash\"></a>rehash</h3><h4 id=\"进行rehash的条件\"><a href=\"#进行rehash的条件\" class=\"headerlink\" title=\"进行rehash的条件\"></a>进行rehash的条件</h4><p>扩容：</p>\n<ol>\n<li>当服务器没有执行bgsave和bgrewriteaof时，负载因子大于等于1</li>\n<li>当服务器执行bgsave或者bgrewriteaof时，负载因子大于等于5<br>(负载因子=哈希表已用大小/哈希表大小)</li>\n</ol>\n<p>为什么会有这样的区分？</p>\n<p>缩容：当负载因子小于0.1时</p>\n<h4 id=\"rehash过程\"><a href=\"#rehash过程\" class=\"headerlink\" title=\"rehash过程\"></a>rehash过程</h4><ol>\n<li>确定ht[1]哈希表的大小<br>如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；<br>如果是缩容，那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</li>\n<li>将ht[0]的kv迁移到ht[1]<br>利用渐进式迁移策略。<br>步骤：<br>a. 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。<br>b. 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。<br>c. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。<br>d. 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li>\n<li>释放ht[0], 将ht[1]设置为ht[0]，并在ht[1]上申请空的哈希表</li>\n</ol>\n","excerpt":"<p>redis字典的实现在某些地方的设计很类似于jdk中hashmap的设计，如解决冲突方面都是利用了链式法解决冲突的。在存储结构和rehash方案上，redis的hash实现明显比hashmap更有优势。<br>redis字典实现：<br>","more":"</p>\n<h3 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h3><p>字典底层的存储结构图如下：<br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/redis-hash.png\" alt=\"hash存储结构图\"></p>\n<pre><code>typedef struct dict {\n    dictType* type; // 特定函数的类型\n    void* privdata; //特定函数的参数\n    dictht* ht; //哈希表\n    int rehashidx; //rehash进度。-1表示未开始\n} dict;\n\ntypedef struct dictType {\n} dictType;\n\ntypedef struct dictht {\n    unsigned long size; //哈希表大小\n    unsigned long sizemask; //掩码，用来计算位置\n    unsiged long used; //已经使用的数量\n    dictEntry **table; //哈希表数组\n} dictht;\n\ntypedef struct dictEntry {\n    void* key; // key\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v; // value\n    struct dictEntry *next; //形成链表\n} dictEntry;\n</code></pre><h3 id=\"哈希函数\"><a href=\"#哈希函数\" class=\"headerlink\" title=\"哈希函数\"></a>哈希函数</h3><p>字典计算出每个key最终放的位置是通过：</p>\n<pre><code>// 通过哈希函数计算出哈希值\nhash = dict-&gt;type-&gt;hashFunction(key);\n// 通过哈希值计算出最终索引的位置\nindex = hash &amp; dict-&gt;ht[x].sizemask;\n</code></pre><p>哈希函数用的是：murmurhash2</p>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><p>当多个key计算出的索引值一样的话，通过拉链法解决冲突。</p>\n<h3 id=\"rehash\"><a href=\"#rehash\" class=\"headerlink\" title=\"rehash\"></a>rehash</h3><h4 id=\"进行rehash的条件\"><a href=\"#进行rehash的条件\" class=\"headerlink\" title=\"进行rehash的条件\"></a>进行rehash的条件</h4><p>扩容：</p>\n<ol>\n<li>当服务器没有执行bgsave和bgrewriteaof时，负载因子大于等于1</li>\n<li>当服务器执行bgsave或者bgrewriteaof时，负载因子大于等于5<br>(负载因子=哈希表已用大小/哈希表大小)</li>\n</ol>\n<p>为什么会有这样的区分？</p>\n<p>缩容：当负载因子小于0.1时</p>\n<h4 id=\"rehash过程\"><a href=\"#rehash过程\" class=\"headerlink\" title=\"rehash过程\"></a>rehash过程</h4><ol>\n<li>确定ht[1]哈希表的大小<br>如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；<br>如果是缩容，那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</li>\n<li>将ht[0]的kv迁移到ht[1]<br>利用渐进式迁移策略。<br>步骤：<br>a. 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。<br>b. 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。<br>c. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。<br>d. 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li>\n<li>释放ht[0], 将ht[1]设置为ht[0]，并在ht[1]上申请空的哈希表</li>\n</ol>"},{"title":"threadlocal的那些事儿","_content":"threadlocal是另外一种解决多线程并发问题的方案。其主要思想是在每个线程中维护一份共享变量的副本。\n<!--more-->\n# 问题的由来\n\n看下面日期转换的代码：\n\n    public class ThreadLocalTest1 {\n        private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\n\n        static class PrintDate implements Runnable {\n            private int i;\n\n            public PrintDate(int i) {\n                this.i = i;\n            }\n\n            @Override\n            public void run() {\n                try {\n                    Date date = simpleDateFormat.parse(\"2016-07-21\" + \" \" + \"10:10:\" + i % 60);\n                    System.out.println(date);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n                                                                                                                                           public static void main(String[] args) {\n            Executor executor = Executors.newCachedThreadPool();\n            for (int i = 0; i < 10; i++) {\n                executor.execute(new PrintDate(i));\n            }\n        }\n    }\n\n上面的代码运行会出现抛出异常：\n```\njava.lang.NumberFormatException: multiple points\n```\n这是因为多线程访问parse方法时，会对SimpleDateFormat的内部变量造成不确定的修改，从而会抛出异常。\n解决方法可以是加锁 或者是 threadlocal。加锁的话，性能会造成影响。threadlocal是以空间换时间的策略。改变后的代码如下：\n\n    public class ThreadLocalTest {\n\n        private static ThreadLocal<SimpleDateFormat> simpleDateFormats = new ThreadLocal<SimpleDateFormat>() {\n            @Override\n            protected SimpleDateFormat initialValue() {\n                return new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\n            }\n        };\n\n        static class PrintDate implements Runnable {\n            private int i;\n\n            public PrintDate(int i) {\n                this.i = i;\n            }\n\n            @Override\n            public void run() {\n                try {\n                    SimpleDateFormat simpleDateFormat = simpleDateFormats.get();\n                    Date date = simpleDateFormat.parse(\"2016-07-21\" + \" \" + \"10:10:\" + i % 60);\n                    System.out.println(date);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                                                                                                                                               }\n                                                                                                                                                                                                                                                \n        }\n        \n        public static void main(String[] args){                   \n            Executor executor = Executors.newCachedThreadPool();\n            for (int i = 0; i < 10; i++) {\n                executor.execute(new PrintDate(i));\n                                                                                                                                                }\n                                                                                                                                           }\n\n    }\n\n# threadlocal的原理\nthreadlocal的原理，就是每个线程维护一份共享变量的副本。其内部实现图，如下：\n\n![threadlocal结构图](https://raw.githubusercontent.com/buptlsy/images/gh-pages/threadlocal-struct.png)\n\n## threadlocalmap的内部实现\nThreadLocalMap是自定义实现的hashmap，仅仅为了维护threadlocal的值。\nthreadlocalMap的实现和hashmap的实现有很大的差别。threadlocalmap只是单纯的用数组实现，当出现冲突时，利用 线性探测法 来找到空的位置插入。而且它通过弱引用和在get、set方法中处理key为null的途径，极好的防止了内存泄漏的问题。\n\n[ThreadLocal代码的部分注释](https://github.com/buptlsy/java/blob/master/jdkSourceCode/ThreadLocal.java)\n\n","source":"_posts/theadlocal.md","raw":"title: threadlocal的那些事儿\ncategories: java\ntags: java\n---\nthreadlocal是另外一种解决多线程并发问题的方案。其主要思想是在每个线程中维护一份共享变量的副本。\n<!--more-->\n# 问题的由来\n\n看下面日期转换的代码：\n\n    public class ThreadLocalTest1 {\n        private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\n\n        static class PrintDate implements Runnable {\n            private int i;\n\n            public PrintDate(int i) {\n                this.i = i;\n            }\n\n            @Override\n            public void run() {\n                try {\n                    Date date = simpleDateFormat.parse(\"2016-07-21\" + \" \" + \"10:10:\" + i % 60);\n                    System.out.println(date);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n                                                                                                                                           public static void main(String[] args) {\n            Executor executor = Executors.newCachedThreadPool();\n            for (int i = 0; i < 10; i++) {\n                executor.execute(new PrintDate(i));\n            }\n        }\n    }\n\n上面的代码运行会出现抛出异常：\n```\njava.lang.NumberFormatException: multiple points\n```\n这是因为多线程访问parse方法时，会对SimpleDateFormat的内部变量造成不确定的修改，从而会抛出异常。\n解决方法可以是加锁 或者是 threadlocal。加锁的话，性能会造成影响。threadlocal是以空间换时间的策略。改变后的代码如下：\n\n    public class ThreadLocalTest {\n\n        private static ThreadLocal<SimpleDateFormat> simpleDateFormats = new ThreadLocal<SimpleDateFormat>() {\n            @Override\n            protected SimpleDateFormat initialValue() {\n                return new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\n            }\n        };\n\n        static class PrintDate implements Runnable {\n            private int i;\n\n            public PrintDate(int i) {\n                this.i = i;\n            }\n\n            @Override\n            public void run() {\n                try {\n                    SimpleDateFormat simpleDateFormat = simpleDateFormats.get();\n                    Date date = simpleDateFormat.parse(\"2016-07-21\" + \" \" + \"10:10:\" + i % 60);\n                    System.out.println(date);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                                                                                                                                               }\n                                                                                                                                                                                                                                                \n        }\n        \n        public static void main(String[] args){                   \n            Executor executor = Executors.newCachedThreadPool();\n            for (int i = 0; i < 10; i++) {\n                executor.execute(new PrintDate(i));\n                                                                                                                                                }\n                                                                                                                                           }\n\n    }\n\n# threadlocal的原理\nthreadlocal的原理，就是每个线程维护一份共享变量的副本。其内部实现图，如下：\n\n![threadlocal结构图](https://raw.githubusercontent.com/buptlsy/images/gh-pages/threadlocal-struct.png)\n\n## threadlocalmap的内部实现\nThreadLocalMap是自定义实现的hashmap，仅仅为了维护threadlocal的值。\nthreadlocalMap的实现和hashmap的实现有很大的差别。threadlocalmap只是单纯的用数组实现，当出现冲突时，利用 线性探测法 来找到空的位置插入。而且它通过弱引用和在get、set方法中处理key为null的途径，极好的防止了内存泄漏的问题。\n\n[ThreadLocal代码的部分注释](https://github.com/buptlsy/java/blob/master/jdkSourceCode/ThreadLocal.java)\n\n","slug":"theadlocal","published":1,"date":"2016-07-21T02:47:41.000Z","updated":"2016-07-21T10:09:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2ec000u33fyg4zowlxr","content":"<p>threadlocal是另外一种解决多线程并发问题的方案。其主要思想是在每个线程中维护一份共享变量的副本。<br><a id=\"more\"></a></p>\n<h1 id=\"问题的由来\"><a href=\"#问题的由来\" class=\"headerlink\" title=\"问题的由来\"></a>问题的由来</h1><p>看下面日期转换的代码：</p>\n<pre><code>public class ThreadLocalTest1 {\n    private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);\n\n    static class PrintDate implements Runnable {\n        private int i;\n\n        public PrintDate(int i) {\n            this.i = i;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Date date = simpleDateFormat.parse(&quot;2016-07-21&quot; + &quot; &quot; + &quot;10:10:&quot; + i % 60);\n                System.out.println(date);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n                                                                                                                                       public static void main(String[] args) {\n        Executor executor = Executors.newCachedThreadPool();\n        for (int i = 0; i &lt; 10; i++) {\n            executor.execute(new PrintDate(i));\n        }\n    }\n}\n</code></pre><p>上面的代码运行会出现抛出异常：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.NumberFormatException: multiple points</span><br></pre></td></tr></table></figure></p>\n<p>这是因为多线程访问parse方法时，会对SimpleDateFormat的内部变量造成不确定的修改，从而会抛出异常。<br>解决方法可以是加锁 或者是 threadlocal。加锁的话，性能会造成影响。threadlocal是以空间换时间的策略。改变后的代码如下：</p>\n<pre><code>public class ThreadLocalTest {\n\n    private static ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormats = new ThreadLocal&lt;SimpleDateFormat&gt;() {\n        @Override\n        protected SimpleDateFormat initialValue() {\n            return new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);\n        }\n    };\n\n    static class PrintDate implements Runnable {\n        private int i;\n\n        public PrintDate(int i) {\n            this.i = i;\n        }\n\n        @Override\n        public void run() {\n            try {\n                SimpleDateFormat simpleDateFormat = simpleDateFormats.get();\n                Date date = simpleDateFormat.parse(&quot;2016-07-21&quot; + &quot; &quot; + &quot;10:10:&quot; + i % 60);\n                System.out.println(date);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n                                                                                                                                           }\n\n    }\n\n    public static void main(String[] args){                   \n        Executor executor = Executors.newCachedThreadPool();\n        for (int i = 0; i &lt; 10; i++) {\n            executor.execute(new PrintDate(i));\n                                                                                                                                            }\n                                                                                                                                       }\n\n}\n</code></pre><h1 id=\"threadlocal的原理\"><a href=\"#threadlocal的原理\" class=\"headerlink\" title=\"threadlocal的原理\"></a>threadlocal的原理</h1><p>threadlocal的原理，就是每个线程维护一份共享变量的副本。其内部实现图，如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/buptlsy/images/gh-pages/threadlocal-struct.png\" alt=\"threadlocal结构图\"></p>\n<h2 id=\"threadlocalmap的内部实现\"><a href=\"#threadlocalmap的内部实现\" class=\"headerlink\" title=\"threadlocalmap的内部实现\"></a>threadlocalmap的内部实现</h2><p>ThreadLocalMap是自定义实现的hashmap，仅仅为了维护threadlocal的值。<br>threadlocalMap的实现和hashmap的实现有很大的差别。threadlocalmap只是单纯的用数组实现，当出现冲突时，利用 线性探测法 来找到空的位置插入。而且它通过弱引用和在get、set方法中处理key为null的途径，极好的防止了内存泄漏的问题。</p>\n<p><a href=\"https://github.com/buptlsy/java/blob/master/jdkSourceCode/ThreadLocal.java\" target=\"_blank\" rel=\"external\">ThreadLocal代码的部分注释</a></p>\n","excerpt":"<p>threadlocal是另外一种解决多线程并发问题的方案。其主要思想是在每个线程中维护一份共享变量的副本。<br>","more":"</p>\n<h1 id=\"问题的由来\"><a href=\"#问题的由来\" class=\"headerlink\" title=\"问题的由来\"></a>问题的由来</h1><p>看下面日期转换的代码：</p>\n<pre><code>public class ThreadLocalTest1 {\n    private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);\n\n    static class PrintDate implements Runnable {\n        private int i;\n\n        public PrintDate(int i) {\n            this.i = i;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Date date = simpleDateFormat.parse(&quot;2016-07-21&quot; + &quot; &quot; + &quot;10:10:&quot; + i % 60);\n                System.out.println(date);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n                                                                                                                                       public static void main(String[] args) {\n        Executor executor = Executors.newCachedThreadPool();\n        for (int i = 0; i &lt; 10; i++) {\n            executor.execute(new PrintDate(i));\n        }\n    }\n}\n</code></pre><p>上面的代码运行会出现抛出异常：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.NumberFormatException: multiple points</span><br></pre></td></tr></table></figure></p>\n<p>这是因为多线程访问parse方法时，会对SimpleDateFormat的内部变量造成不确定的修改，从而会抛出异常。<br>解决方法可以是加锁 或者是 threadlocal。加锁的话，性能会造成影响。threadlocal是以空间换时间的策略。改变后的代码如下：</p>\n<pre><code>public class ThreadLocalTest {\n\n    private static ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormats = new ThreadLocal&lt;SimpleDateFormat&gt;() {\n        @Override\n        protected SimpleDateFormat initialValue() {\n            return new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);\n        }\n    };\n\n    static class PrintDate implements Runnable {\n        private int i;\n\n        public PrintDate(int i) {\n            this.i = i;\n        }\n\n        @Override\n        public void run() {\n            try {\n                SimpleDateFormat simpleDateFormat = simpleDateFormats.get();\n                Date date = simpleDateFormat.parse(&quot;2016-07-21&quot; + &quot; &quot; + &quot;10:10:&quot; + i % 60);\n                System.out.println(date);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n                                                                                                                                           }\n\n    }\n\n    public static void main(String[] args){                   \n        Executor executor = Executors.newCachedThreadPool();\n        for (int i = 0; i &lt; 10; i++) {\n            executor.execute(new PrintDate(i));\n                                                                                                                                            }\n                                                                                                                                       }\n\n}\n</code></pre><h1 id=\"threadlocal的原理\"><a href=\"#threadlocal的原理\" class=\"headerlink\" title=\"threadlocal的原理\"></a>threadlocal的原理</h1><p>threadlocal的原理，就是每个线程维护一份共享变量的副本。其内部实现图，如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/buptlsy/images/gh-pages/threadlocal-struct.png\" alt=\"threadlocal结构图\"></p>\n<h2 id=\"threadlocalmap的内部实现\"><a href=\"#threadlocalmap的内部实现\" class=\"headerlink\" title=\"threadlocalmap的内部实现\"></a>threadlocalmap的内部实现</h2><p>ThreadLocalMap是自定义实现的hashmap，仅仅为了维护threadlocal的值。<br>threadlocalMap的实现和hashmap的实现有很大的差别。threadlocalmap只是单纯的用数组实现，当出现冲突时，利用 线性探测法 来找到空的位置插入。而且它通过弱引用和在get、set方法中处理key为null的途径，极好的防止了内存泄漏的问题。</p>\n<p><a href=\"https://github.com/buptlsy/java/blob/master/jdkSourceCode/ThreadLocal.java\">ThreadLocal代码的部分注释</a></p>"},{"title":"redis的动态字符串和链表","_content":"redis的两个基本的数据结构：动态字符串和链表\n<!--more-->\n### 动态字符串（sds）\n\n#### 结构\n\nsds的结构主要包括：free(未使用空间的数量)，len(已使用空间的数量),buf(存储字符串的地方)。\n![sds结构](https://raw.githubusercontent.com/buptlsy/images/master/redis-sds.png)\n在数据的结尾会加上'\\0'\n\n#### 好处\n\n1. 常量时间复杂度获取字符串大小。因为可以直接从len变量中取到值。\n2. 避免缓冲区溢出。\n类比c语言的strcat()函数，strcat在拼接字符串时，有可能会出现缓冲区溢出的情况。(strcat(dest, src), 如果dest字符串的剩余空间大小不足以放下src，那么src会覆盖原有的内容，导致缓冲区溢出)。\nsds的拼接函数，会在做拼接操作前，看看dest是否有足够的free空间（至于怎样分配，请看第3条）。\n3. 在动态增加和减少字符串时，减小分配内存的次数\n出现的两种问题：\n（1）缓冲区溢出。第2点介绍的内容。\n（2）内存泄漏。如果不回收不用的空间，会出现内存泄漏的问题。\n解决办法：\n（1）扩展字符串时，分配内存空间的策略--空间预分配策略\n当分配后的内存空间小于1M，会将free和len设置为相同的值；\n当分配后的内存空间大于1M，则把free的值设为1M。\n（2）剪断字符串时，会回收不用的空间--惰性回收策略\n只是简单的将不用的空间数量加到free上。\n这两种策略都是减少了内存分配次数。\n4. 二进制安全\nredis用buf数组来保存二进制数据。主要是因为它不是用'\\0'来标识结尾，而是用len来判断字符串是否结束。\n\n#### 主要操作\n\n### 链表(list)\n\nlist的实现是通过双链表实现的。\n\n### 结构\n\n节点：\n    \n    typedef struct listNode {\n        //前置节点\n        struct listNode *prev;\n        //后置节点\n        struct listNode *next;\n        //节点的值\n        void *value;\n    }\n\n链表：\n    \n    typedef struct list {\n        //表头节点\n        listNode *head;\n        //表尾节点\n        listNode *tail;\n        //节点个数\n        unsigned long len;\n        //节点复制函数\n        void *(*dup)(void *ptr);\n        //节点释放函数\n        void *(*free)(void *ptr);\n        //节点值对比函数\n        void *(*match)(void *ptr, void *key);\n    }\n\n\n![list结构](https://raw.githubusercontent.com/buptlsy/images/master/redis-linkedlist.png)\n\n#### 好处\n\n1. 双链表的好处\n2. len的好处\n3. 多态。链表使用void* 保存节点值，并且可以通过dup、free、match三个属性为节点值设置类型特定的函数，所以链表可以用来保存各种不同类型的值。\n\n#### 主要操作\n","source":"_posts/redis_sds_list.md","raw":"---\ntitle: redis的动态字符串和链表\ncategories: redis\ntags: redis\n\n---\nredis的两个基本的数据结构：动态字符串和链表\n<!--more-->\n### 动态字符串（sds）\n\n#### 结构\n\nsds的结构主要包括：free(未使用空间的数量)，len(已使用空间的数量),buf(存储字符串的地方)。\n![sds结构](https://raw.githubusercontent.com/buptlsy/images/master/redis-sds.png)\n在数据的结尾会加上'\\0'\n\n#### 好处\n\n1. 常量时间复杂度获取字符串大小。因为可以直接从len变量中取到值。\n2. 避免缓冲区溢出。\n类比c语言的strcat()函数，strcat在拼接字符串时，有可能会出现缓冲区溢出的情况。(strcat(dest, src), 如果dest字符串的剩余空间大小不足以放下src，那么src会覆盖原有的内容，导致缓冲区溢出)。\nsds的拼接函数，会在做拼接操作前，看看dest是否有足够的free空间（至于怎样分配，请看第3条）。\n3. 在动态增加和减少字符串时，减小分配内存的次数\n出现的两种问题：\n（1）缓冲区溢出。第2点介绍的内容。\n（2）内存泄漏。如果不回收不用的空间，会出现内存泄漏的问题。\n解决办法：\n（1）扩展字符串时，分配内存空间的策略--空间预分配策略\n当分配后的内存空间小于1M，会将free和len设置为相同的值；\n当分配后的内存空间大于1M，则把free的值设为1M。\n（2）剪断字符串时，会回收不用的空间--惰性回收策略\n只是简单的将不用的空间数量加到free上。\n这两种策略都是减少了内存分配次数。\n4. 二进制安全\nredis用buf数组来保存二进制数据。主要是因为它不是用'\\0'来标识结尾，而是用len来判断字符串是否结束。\n\n#### 主要操作\n\n### 链表(list)\n\nlist的实现是通过双链表实现的。\n\n### 结构\n\n节点：\n    \n    typedef struct listNode {\n        //前置节点\n        struct listNode *prev;\n        //后置节点\n        struct listNode *next;\n        //节点的值\n        void *value;\n    }\n\n链表：\n    \n    typedef struct list {\n        //表头节点\n        listNode *head;\n        //表尾节点\n        listNode *tail;\n        //节点个数\n        unsigned long len;\n        //节点复制函数\n        void *(*dup)(void *ptr);\n        //节点释放函数\n        void *(*free)(void *ptr);\n        //节点值对比函数\n        void *(*match)(void *ptr, void *key);\n    }\n\n\n![list结构](https://raw.githubusercontent.com/buptlsy/images/master/redis-linkedlist.png)\n\n#### 好处\n\n1. 双链表的好处\n2. len的好处\n3. 多态。链表使用void* 保存节点值，并且可以通过dup、free、match三个属性为节点值设置类型特定的函数，所以链表可以用来保存各种不同类型的值。\n\n#### 主要操作\n","slug":"redis_sds_list","published":1,"date":"2016-06-03T01:54:00.000Z","updated":"2016-06-03T12:55:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2ee000x33fygoy4c5ks","content":"<p>redis的两个基本的数据结构：动态字符串和链表<br><a id=\"more\"></a></p>\n<h3 id=\"动态字符串（sds）\"><a href=\"#动态字符串（sds）\" class=\"headerlink\" title=\"动态字符串（sds）\"></a>动态字符串（sds）</h3><h4 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h4><p>sds的结构主要包括：free(未使用空间的数量)，len(已使用空间的数量),buf(存储字符串的地方)。<br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/redis-sds.png\" alt=\"sds结构\"><br>在数据的结尾会加上’\\0’</p>\n<h4 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h4><ol>\n<li>常量时间复杂度获取字符串大小。因为可以直接从len变量中取到值。</li>\n<li>避免缓冲区溢出。<br>类比c语言的strcat()函数，strcat在拼接字符串时，有可能会出现缓冲区溢出的情况。(strcat(dest, src), 如果dest字符串的剩余空间大小不足以放下src，那么src会覆盖原有的内容，导致缓冲区溢出)。<br>sds的拼接函数，会在做拼接操作前，看看dest是否有足够的free空间（至于怎样分配，请看第3条）。</li>\n<li>在动态增加和减少字符串时，减小分配内存的次数<br>出现的两种问题：<br>（1）缓冲区溢出。第2点介绍的内容。<br>（2）内存泄漏。如果不回收不用的空间，会出现内存泄漏的问题。<br>解决办法：<br>（1）扩展字符串时，分配内存空间的策略–空间预分配策略<br>当分配后的内存空间小于1M，会将free和len设置为相同的值；<br>当分配后的内存空间大于1M，则把free的值设为1M。<br>（2）剪断字符串时，会回收不用的空间–惰性回收策略<br>只是简单的将不用的空间数量加到free上。<br>这两种策略都是减少了内存分配次数。</li>\n<li>二进制安全<br>redis用buf数组来保存二进制数据。主要是因为它不是用’\\0’来标识结尾，而是用len来判断字符串是否结束。</li>\n</ol>\n<h4 id=\"主要操作\"><a href=\"#主要操作\" class=\"headerlink\" title=\"主要操作\"></a>主要操作</h4><h3 id=\"链表-list\"><a href=\"#链表-list\" class=\"headerlink\" title=\"链表(list)\"></a>链表(list)</h3><p>list的实现是通过双链表实现的。</p>\n<h3 id=\"结构-1\"><a href=\"#结构-1\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>节点：</p>\n<pre><code>typedef struct listNode {\n    //前置节点\n    struct listNode *prev;\n    //后置节点\n    struct listNode *next;\n    //节点的值\n    void *value;\n}\n</code></pre><p>链表：</p>\n<pre><code>typedef struct list {\n    //表头节点\n    listNode *head;\n    //表尾节点\n    listNode *tail;\n    //节点个数\n    unsigned long len;\n    //节点复制函数\n    void *(*dup)(void *ptr);\n    //节点释放函数\n    void *(*free)(void *ptr);\n    //节点值对比函数\n    void *(*match)(void *ptr, void *key);\n}\n</code></pre><p><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/redis-linkedlist.png\" alt=\"list结构\"></p>\n<h4 id=\"好处-1\"><a href=\"#好处-1\" class=\"headerlink\" title=\"好处\"></a>好处</h4><ol>\n<li>双链表的好处</li>\n<li>len的好处</li>\n<li>多态。链表使用void* 保存节点值，并且可以通过dup、free、match三个属性为节点值设置类型特定的函数，所以链表可以用来保存各种不同类型的值。</li>\n</ol>\n<h4 id=\"主要操作-1\"><a href=\"#主要操作-1\" class=\"headerlink\" title=\"主要操作\"></a>主要操作</h4>","excerpt":"<p>redis的两个基本的数据结构：动态字符串和链表<br>","more":"</p>\n<h3 id=\"动态字符串（sds）\"><a href=\"#动态字符串（sds）\" class=\"headerlink\" title=\"动态字符串（sds）\"></a>动态字符串（sds）</h3><h4 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h4><p>sds的结构主要包括：free(未使用空间的数量)，len(已使用空间的数量),buf(存储字符串的地方)。<br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/redis-sds.png\" alt=\"sds结构\"><br>在数据的结尾会加上’\\0’</p>\n<h4 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h4><ol>\n<li>常量时间复杂度获取字符串大小。因为可以直接从len变量中取到值。</li>\n<li>避免缓冲区溢出。<br>类比c语言的strcat()函数，strcat在拼接字符串时，有可能会出现缓冲区溢出的情况。(strcat(dest, src), 如果dest字符串的剩余空间大小不足以放下src，那么src会覆盖原有的内容，导致缓冲区溢出)。<br>sds的拼接函数，会在做拼接操作前，看看dest是否有足够的free空间（至于怎样分配，请看第3条）。</li>\n<li>在动态增加和减少字符串时，减小分配内存的次数<br>出现的两种问题：<br>（1）缓冲区溢出。第2点介绍的内容。<br>（2）内存泄漏。如果不回收不用的空间，会出现内存泄漏的问题。<br>解决办法：<br>（1）扩展字符串时，分配内存空间的策略–空间预分配策略<br>当分配后的内存空间小于1M，会将free和len设置为相同的值；<br>当分配后的内存空间大于1M，则把free的值设为1M。<br>（2）剪断字符串时，会回收不用的空间–惰性回收策略<br>只是简单的将不用的空间数量加到free上。<br>这两种策略都是减少了内存分配次数。</li>\n<li>二进制安全<br>redis用buf数组来保存二进制数据。主要是因为它不是用’\\0’来标识结尾，而是用len来判断字符串是否结束。</li>\n</ol>\n<h4 id=\"主要操作\"><a href=\"#主要操作\" class=\"headerlink\" title=\"主要操作\"></a>主要操作</h4><h3 id=\"链表-list\"><a href=\"#链表-list\" class=\"headerlink\" title=\"链表(list)\"></a>链表(list)</h3><p>list的实现是通过双链表实现的。</p>\n<h3 id=\"结构-1\"><a href=\"#结构-1\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>节点：</p>\n<pre><code>typedef struct listNode {\n    //前置节点\n    struct listNode *prev;\n    //后置节点\n    struct listNode *next;\n    //节点的值\n    void *value;\n}\n</code></pre><p>链表：</p>\n<pre><code>typedef struct list {\n    //表头节点\n    listNode *head;\n    //表尾节点\n    listNode *tail;\n    //节点个数\n    unsigned long len;\n    //节点复制函数\n    void *(*dup)(void *ptr);\n    //节点释放函数\n    void *(*free)(void *ptr);\n    //节点值对比函数\n    void *(*match)(void *ptr, void *key);\n}\n</code></pre><p><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/redis-linkedlist.png\" alt=\"list结构\"></p>\n<h4 id=\"好处-1\"><a href=\"#好处-1\" class=\"headerlink\" title=\"好处\"></a>好处</h4><ol>\n<li>双链表的好处</li>\n<li>len的好处</li>\n<li>多态。链表使用void* 保存节点值，并且可以通过dup、free、match三个属性为节点值设置类型特定的函数，所以链表可以用来保存各种不同类型的值。</li>\n</ol>\n<h4 id=\"主要操作-1\"><a href=\"#主要操作-1\" class=\"headerlink\" title=\"主要操作\"></a>主要操作</h4>"},{"title":"mysql索引那些事儿","_content":"在创建数据库表时，需要考虑到很多的因素。不仅仅是每个字段的构成，还有主键。其实主键就是唯一索引的一种。因为mysql有多种存储引擎，每种引擎用的索引类型也不一样。\n<!--more-->\n## 索引的基本操作\n\n    #查看表所用的存储引擎\n    show table status from database where name='table' \\G;\n    #更改数据库表所用的引擎\n    alter table 表名 engine=myisam;\n    #创建多列索引\n    alter table 表名 add index 索引名(col1, col2);\n    #创建唯一索引\n    alter table 表名 add unique 索引名(col1, col2);\n    #创建主键索引\n    alter table 表名 add primary key 索引名(col1);\n    #查看一条查询语句所用到的索引情况\n    explain 查询语句\n\n## 索引的分类\n\n### b树索引（innodb引擎）\n\nmyisam引擎和innodb引擎是用b+树实现的索引。b+树的叶子节点存储具体的行信息。叶子节点同时构成了一个链表。因为b+       树的一些特性，所以此索引也具有很多优点：查询效率高（O(h),h为树高))，范围查询效率高。\n\n#### myisam引擎和innodb引擎的区别\n\nmyisam引擎和innodb引擎在一些地方存在差异（分别从主键索引和二级索引方面考虑）：\n主键索引：myisam引擎的数据文件和索引文件是分开的。而innodb引擎的数据和索引是放在一起的。\nmyisam引擎索引：\n![myisam引擎索引](https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_my_primarykey.jpg)\ninnodb引擎索引：\n![innodb引擎索引](https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_innodb_primarykey.jpg)\n二级索引：myisam引擎的二级索引的data部分存放的是行指针，而innodb引擎存放的是主键。\nmyisam引擎索引：\n![myisam引擎索引](https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_myisam_secondarykey.jpg)\ninnodb引擎索引：\n![innodb引擎索引](https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_innodb_secondarykey.jpg)\n\n#### b+树索引生效的地方\n\n举个例子（以myisam引擎为例）：假设表student主键为id, 多列索引(A, B)。分析以下几个例子，是否用到了索引(最左前缀原则和隔离列)：\n1. select * from student where A=xxx and B like '%xxx%';\n2. select * from student where A=xxx;\n3. select * from student where A=xxx and id=xx;\n4. select * from student where B=xxx;\n5. select * from student where A=xxx order by id asc;\n6. select * from student where A=xxx and B=xxx order by id asc;\n7. select A, B from student where id=xxx;\n8. select * from student where A like '%xx%' and B=xxx;\n9. select * from student where A like 'xxx%' and B=xxx;\n10. select * from student where A+1=10;\n\n#### b+树索引的优势\n\ninnodb引擎是用b+树实现的索引。b+树的叶子节点存储具体的行信息。叶子节点同时构成了一个链表。因为b+树的一些特性，所以此索引也具有很多优点：查询效率高（O(h),h为树高))，范围查询效率高。\n\n### 哈希索引 （memory）\n\n\n\n## 全文索引（暂时没有研究）\n\n### 唯一索引\n\n唯一索引保证任意两行的索引都不相同。\n\n### 聚簇索引\n\n行的物理位置和索引的顺序一致。\n\n###  \n\n## 索引的作用\n\n## 引用[reference]\nhttp://database.51cto.com/art/201504/473322_all.htm\n","source":"_posts/mysql-index.md","raw":"---\ntitle: mysql索引那些事儿\ncategories: mysql\ntags: msql\n\n---\n在创建数据库表时，需要考虑到很多的因素。不仅仅是每个字段的构成，还有主键。其实主键就是唯一索引的一种。因为mysql有多种存储引擎，每种引擎用的索引类型也不一样。\n<!--more-->\n## 索引的基本操作\n\n    #查看表所用的存储引擎\n    show table status from database where name='table' \\G;\n    #更改数据库表所用的引擎\n    alter table 表名 engine=myisam;\n    #创建多列索引\n    alter table 表名 add index 索引名(col1, col2);\n    #创建唯一索引\n    alter table 表名 add unique 索引名(col1, col2);\n    #创建主键索引\n    alter table 表名 add primary key 索引名(col1);\n    #查看一条查询语句所用到的索引情况\n    explain 查询语句\n\n## 索引的分类\n\n### b树索引（innodb引擎）\n\nmyisam引擎和innodb引擎是用b+树实现的索引。b+树的叶子节点存储具体的行信息。叶子节点同时构成了一个链表。因为b+       树的一些特性，所以此索引也具有很多优点：查询效率高（O(h),h为树高))，范围查询效率高。\n\n#### myisam引擎和innodb引擎的区别\n\nmyisam引擎和innodb引擎在一些地方存在差异（分别从主键索引和二级索引方面考虑）：\n主键索引：myisam引擎的数据文件和索引文件是分开的。而innodb引擎的数据和索引是放在一起的。\nmyisam引擎索引：\n![myisam引擎索引](https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_my_primarykey.jpg)\ninnodb引擎索引：\n![innodb引擎索引](https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_innodb_primarykey.jpg)\n二级索引：myisam引擎的二级索引的data部分存放的是行指针，而innodb引擎存放的是主键。\nmyisam引擎索引：\n![myisam引擎索引](https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_myisam_secondarykey.jpg)\ninnodb引擎索引：\n![innodb引擎索引](https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_innodb_secondarykey.jpg)\n\n#### b+树索引生效的地方\n\n举个例子（以myisam引擎为例）：假设表student主键为id, 多列索引(A, B)。分析以下几个例子，是否用到了索引(最左前缀原则和隔离列)：\n1. select * from student where A=xxx and B like '%xxx%';\n2. select * from student where A=xxx;\n3. select * from student where A=xxx and id=xx;\n4. select * from student where B=xxx;\n5. select * from student where A=xxx order by id asc;\n6. select * from student where A=xxx and B=xxx order by id asc;\n7. select A, B from student where id=xxx;\n8. select * from student where A like '%xx%' and B=xxx;\n9. select * from student where A like 'xxx%' and B=xxx;\n10. select * from student where A+1=10;\n\n#### b+树索引的优势\n\ninnodb引擎是用b+树实现的索引。b+树的叶子节点存储具体的行信息。叶子节点同时构成了一个链表。因为b+树的一些特性，所以此索引也具有很多优点：查询效率高（O(h),h为树高))，范围查询效率高。\n\n### 哈希索引 （memory）\n\n\n\n## 全文索引（暂时没有研究）\n\n### 唯一索引\n\n唯一索引保证任意两行的索引都不相同。\n\n### 聚簇索引\n\n行的物理位置和索引的顺序一致。\n\n###  \n\n## 索引的作用\n\n## 引用[reference]\nhttp://database.51cto.com/art/201504/473322_all.htm\n","slug":"mysql-index","published":1,"date":"2016-06-20T06:08:02.000Z","updated":"2016-06-24T06:03:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2ei001233fy9ns4eoys","content":"<p>在创建数据库表时，需要考虑到很多的因素。不仅仅是每个字段的构成，还有主键。其实主键就是唯一索引的一种。因为mysql有多种存储引擎，每种引擎用的索引类型也不一样。<br><a id=\"more\"></a></p>\n<h2 id=\"索引的基本操作\"><a href=\"#索引的基本操作\" class=\"headerlink\" title=\"索引的基本操作\"></a>索引的基本操作</h2><pre><code>#查看表所用的存储引擎\nshow table status from database where name=&apos;table&apos; \\G;\n#更改数据库表所用的引擎\nalter table 表名 engine=myisam;\n#创建多列索引\nalter table 表名 add index 索引名(col1, col2);\n#创建唯一索引\nalter table 表名 add unique 索引名(col1, col2);\n#创建主键索引\nalter table 表名 add primary key 索引名(col1);\n#查看一条查询语句所用到的索引情况\nexplain 查询语句\n</code></pre><h2 id=\"索引的分类\"><a href=\"#索引的分类\" class=\"headerlink\" title=\"索引的分类\"></a>索引的分类</h2><h3 id=\"b树索引（innodb引擎）\"><a href=\"#b树索引（innodb引擎）\" class=\"headerlink\" title=\"b树索引（innodb引擎）\"></a>b树索引（innodb引擎）</h3><p>myisam引擎和innodb引擎是用b+树实现的索引。b+树的叶子节点存储具体的行信息。叶子节点同时构成了一个链表。因为b+       树的一些特性，所以此索引也具有很多优点：查询效率高（O(h),h为树高))，范围查询效率高。</p>\n<h4 id=\"myisam引擎和innodb引擎的区别\"><a href=\"#myisam引擎和innodb引擎的区别\" class=\"headerlink\" title=\"myisam引擎和innodb引擎的区别\"></a>myisam引擎和innodb引擎的区别</h4><p>myisam引擎和innodb引擎在一些地方存在差异（分别从主键索引和二级索引方面考虑）：<br>主键索引：myisam引擎的数据文件和索引文件是分开的。而innodb引擎的数据和索引是放在一起的。<br>myisam引擎索引：<br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_my_primarykey.jpg\" alt=\"myisam引擎索引\"><br>innodb引擎索引：<br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_innodb_primarykey.jpg\" alt=\"innodb引擎索引\"><br>二级索引：myisam引擎的二级索引的data部分存放的是行指针，而innodb引擎存放的是主键。<br>myisam引擎索引：<br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_myisam_secondarykey.jpg\" alt=\"myisam引擎索引\"><br>innodb引擎索引：<br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_innodb_secondarykey.jpg\" alt=\"innodb引擎索引\"></p>\n<h4 id=\"b-树索引生效的地方\"><a href=\"#b-树索引生效的地方\" class=\"headerlink\" title=\"b+树索引生效的地方\"></a>b+树索引生效的地方</h4><p>举个例子（以myisam引擎为例）：假设表student主键为id, 多列索引(A, B)。分析以下几个例子，是否用到了索引(最左前缀原则和隔离列)：</p>\n<ol>\n<li>select * from student where A=xxx and B like ‘%xxx%’;</li>\n<li>select * from student where A=xxx;</li>\n<li>select * from student where A=xxx and id=xx;</li>\n<li>select * from student where B=xxx;</li>\n<li>select * from student where A=xxx order by id asc;</li>\n<li>select * from student where A=xxx and B=xxx order by id asc;</li>\n<li>select A, B from student where id=xxx;</li>\n<li>select * from student where A like ‘%xx%’ and B=xxx;</li>\n<li>select * from student where A like ‘xxx%’ and B=xxx;</li>\n<li>select * from student where A+1=10;</li>\n</ol>\n<h4 id=\"b-树索引的优势\"><a href=\"#b-树索引的优势\" class=\"headerlink\" title=\"b+树索引的优势\"></a>b+树索引的优势</h4><p>innodb引擎是用b+树实现的索引。b+树的叶子节点存储具体的行信息。叶子节点同时构成了一个链表。因为b+树的一些特性，所以此索引也具有很多优点：查询效率高（O(h),h为树高))，范围查询效率高。</p>\n<h3 id=\"哈希索引-（memory）\"><a href=\"#哈希索引-（memory）\" class=\"headerlink\" title=\"哈希索引 （memory）\"></a>哈希索引 （memory）</h3><h2 id=\"全文索引（暂时没有研究）\"><a href=\"#全文索引（暂时没有研究）\" class=\"headerlink\" title=\"全文索引（暂时没有研究）\"></a>全文索引（暂时没有研究）</h2><h3 id=\"唯一索引\"><a href=\"#唯一索引\" class=\"headerlink\" title=\"唯一索引\"></a>唯一索引</h3><p>唯一索引保证任意两行的索引都不相同。</p>\n<h3 id=\"聚簇索引\"><a href=\"#聚簇索引\" class=\"headerlink\" title=\"聚簇索引\"></a>聚簇索引</h3><p>行的物理位置和索引的顺序一致。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h3><h2 id=\"索引的作用\"><a href=\"#索引的作用\" class=\"headerlink\" title=\"索引的作用\"></a>索引的作用</h2><h2 id=\"引用-reference\"><a href=\"#引用-reference\" class=\"headerlink\" title=\"引用[reference]\"></a>引用[reference]</h2><p><a href=\"http://database.51cto.com/art/201504/473322_all.htm\" target=\"_blank\" rel=\"external\">http://database.51cto.com/art/201504/473322_all.htm</a></p>\n","excerpt":"<p>在创建数据库表时，需要考虑到很多的因素。不仅仅是每个字段的构成，还有主键。其实主键就是唯一索引的一种。因为mysql有多种存储引擎，每种引擎用的索引类型也不一样。<br>","more":"</p>\n<h2 id=\"索引的基本操作\"><a href=\"#索引的基本操作\" class=\"headerlink\" title=\"索引的基本操作\"></a>索引的基本操作</h2><pre><code>#查看表所用的存储引擎\nshow table status from database where name=&apos;table&apos; \\G;\n#更改数据库表所用的引擎\nalter table 表名 engine=myisam;\n#创建多列索引\nalter table 表名 add index 索引名(col1, col2);\n#创建唯一索引\nalter table 表名 add unique 索引名(col1, col2);\n#创建主键索引\nalter table 表名 add primary key 索引名(col1);\n#查看一条查询语句所用到的索引情况\nexplain 查询语句\n</code></pre><h2 id=\"索引的分类\"><a href=\"#索引的分类\" class=\"headerlink\" title=\"索引的分类\"></a>索引的分类</h2><h3 id=\"b树索引（innodb引擎）\"><a href=\"#b树索引（innodb引擎）\" class=\"headerlink\" title=\"b树索引（innodb引擎）\"></a>b树索引（innodb引擎）</h3><p>myisam引擎和innodb引擎是用b+树实现的索引。b+树的叶子节点存储具体的行信息。叶子节点同时构成了一个链表。因为b+       树的一些特性，所以此索引也具有很多优点：查询效率高（O(h),h为树高))，范围查询效率高。</p>\n<h4 id=\"myisam引擎和innodb引擎的区别\"><a href=\"#myisam引擎和innodb引擎的区别\" class=\"headerlink\" title=\"myisam引擎和innodb引擎的区别\"></a>myisam引擎和innodb引擎的区别</h4><p>myisam引擎和innodb引擎在一些地方存在差异（分别从主键索引和二级索引方面考虑）：<br>主键索引：myisam引擎的数据文件和索引文件是分开的。而innodb引擎的数据和索引是放在一起的。<br>myisam引擎索引：<br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_my_primarykey.jpg\" alt=\"myisam引擎索引\"><br>innodb引擎索引：<br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_innodb_primarykey.jpg\" alt=\"innodb引擎索引\"><br>二级索引：myisam引擎的二级索引的data部分存放的是行指针，而innodb引擎存放的是主键。<br>myisam引擎索引：<br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_myisam_secondarykey.jpg\" alt=\"myisam引擎索引\"><br>innodb引擎索引：<br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/mysql_index_innodb_secondarykey.jpg\" alt=\"innodb引擎索引\"></p>\n<h4 id=\"b-树索引生效的地方\"><a href=\"#b-树索引生效的地方\" class=\"headerlink\" title=\"b+树索引生效的地方\"></a>b+树索引生效的地方</h4><p>举个例子（以myisam引擎为例）：假设表student主键为id, 多列索引(A, B)。分析以下几个例子，是否用到了索引(最左前缀原则和隔离列)：</p>\n<ol>\n<li>select * from student where A=xxx and B like ‘%xxx%’;</li>\n<li>select * from student where A=xxx;</li>\n<li>select * from student where A=xxx and id=xx;</li>\n<li>select * from student where B=xxx;</li>\n<li>select * from student where A=xxx order by id asc;</li>\n<li>select * from student where A=xxx and B=xxx order by id asc;</li>\n<li>select A, B from student where id=xxx;</li>\n<li>select * from student where A like ‘%xx%’ and B=xxx;</li>\n<li>select * from student where A like ‘xxx%’ and B=xxx;</li>\n<li>select * from student where A+1=10;</li>\n</ol>\n<h4 id=\"b-树索引的优势\"><a href=\"#b-树索引的优势\" class=\"headerlink\" title=\"b+树索引的优势\"></a>b+树索引的优势</h4><p>innodb引擎是用b+树实现的索引。b+树的叶子节点存储具体的行信息。叶子节点同时构成了一个链表。因为b+树的一些特性，所以此索引也具有很多优点：查询效率高（O(h),h为树高))，范围查询效率高。</p>\n<h3 id=\"哈希索引-（memory）\"><a href=\"#哈希索引-（memory）\" class=\"headerlink\" title=\"哈希索引 （memory）\"></a>哈希索引 （memory）</h3><h2 id=\"全文索引（暂时没有研究）\"><a href=\"#全文索引（暂时没有研究）\" class=\"headerlink\" title=\"全文索引（暂时没有研究）\"></a>全文索引（暂时没有研究）</h2><h3 id=\"唯一索引\"><a href=\"#唯一索引\" class=\"headerlink\" title=\"唯一索引\"></a>唯一索引</h3><p>唯一索引保证任意两行的索引都不相同。</p>\n<h3 id=\"聚簇索引\"><a href=\"#聚簇索引\" class=\"headerlink\" title=\"聚簇索引\"></a>聚簇索引</h3><p>行的物理位置和索引的顺序一致。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h3><h2 id=\"索引的作用\"><a href=\"#索引的作用\" class=\"headerlink\" title=\"索引的作用\"></a>索引的作用</h2><h2 id=\"引用-reference\"><a href=\"#引用-reference\" class=\"headerlink\" title=\"引用[reference]\"></a>引用[reference]</h2><p><a href=\"http://database.51cto.com/art/201504/473322_all.htm\">http://database.51cto.com/art/201504/473322_all.htm</a></p>"},{"title":"synchronized和volatile的那些事","_content":"\n","source":"_posts/synchronized_volatile.md","raw":"---\ntitle: synchronized和volatile的那些事\ncategories: java\ntags: java\n---\n\n","slug":"synchronized_volatile","published":1,"date":"2016-05-26T08:21:33.000Z","updated":"2016-05-26T08:21:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2eo001533fy939iy1sr","content":"","excerpt":"","more":""},{"title":"单例模式的实现方式","_content":"单例模式是最简单的一种设计模式。单例模式的通俗理解就是在在程序中类有且只有一个实例存在。\n<!--more-->\n## 5种实现方式\n\n### 懒汉\n懒汉方式即等到需要用到对象的时候再生成实例。\n\n    public class LazyInitialization {\n    \tprivate static Resource resource;\n    \tpublic synchronized static Resource getInstance() {\n    \t\tif (resource == null) resource = new Resource();\n    \t\treturn resource;\n    \t}\n    }\n\n上面方式解决并发问题时用了synchronized，在方法上加锁。这种方式导致并发度不是很高，存在优化的地方。双重检验加锁通过减少加锁的粒度，来优化懒汉方式。\n\n### 双重检验加锁\n通过对实例加锁，减小了加锁的粒度，使并发度更高。\n\n    public class DoubleCheckedLocking {\n    \tprivate static volatile Resource resource;\n    \tpublic static Resource getInstance() {\n    \t\tif (resource == null) {\n\t    \t\tsynchronized(DoubleCheckedLocking.class) {\n\t    \t\t\tif (resource == null) {\n\t    \t\t\t\tresource = new Resource();\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t    \treturn resource;\n    \t}\n    }\n\n通常对双重检验加锁存在两种疑问：\n1.为什么使用volatile?\n其一：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。\n其二：resource = new Resource();这行代码在jvm中执行的过程为：\n\n - (1)给singleton分配内存\n - (2)调用构造函数来初始化成员变量\n - (3)将resource指向分配的内存空间，执行完这步resource才非空。\n \n\n在jvm中存在指令重排序的优化，也就是说步骤2、3的顺序不能保证。如果顺序是(1)-(3)-(2)，则在(3)执行完毕、(2)未执行之前，被线程二抢占了，这时 instance 已经是非 null 了(但却没有初始化)，所以线程二会直接返回 instance，然后使用，然后报错。\n由于volatile关键字可能会屏蔽掉虚拟机中的一些必要的代码优化，所以运行效率并不是很高。\n2.两个if的作用是什么？\n第一个if是如果实例已经存在，就没必要再生成实例了，也就没必要进行加锁了。第二个if是处理并发的问题。当两个线程a、b，a线程拿到锁，b线程等待锁，a线程实例化对象后，释放锁，b线程拿到锁但是这个时候类已经实例化了，没必要进行实例化操作了。所以两个if使得并发度更高。\n\n### 延长初始化占位类模式\n上面两种方式都是实现了延迟加载和线程安全。另外一种方法是使用静态内部类实现延迟加载和线程安全。在某些情况下，JVM已经隐含的为您执行了同步，这些情况下就不用自己再来进行同步控制了。包括：\n 1. 由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时\n 2. 访问final字段时\n \n代码如下：\n\n    public class ResourceFactory {\n    \tpublic static Resource getInstance() {\n    \t\treturn ResourceHolder.resource;\n    \t}\n    \tprivate ResourceFactory() {}\n    \tprivate static class ResourceHolder {\n    \t\tpublic static Resource resource = new Resource();\n\t    }\n    }\n此类方式是很好的实现单例的方式。\n### 饿汉\n通常在加载类的时候，就实例化对象。这是和懒汉不一样的地方。\n    \n    public class EagerInitialization {\n    \tprivate static Resource resource = new Resource();\n    \tpublic static Resource getResource() {\n    \t\treturn resource;\n        }\n    }\n\n### enum\nenum类型是java se5中引入的新特性。\n\n    public enum EnumA {\n\t    Instance;\n    }\n\n为什么enum类型可以保证类只有一个实例？\n1.enum类型反编译后，是一个final类。反编译后的类继承了Enum类型，并且是final类型的，所以这个类不能被继承。同时public static final EnumA Instance;是static final的，说明在程序中第一次用到的时候，会被加载。类似于单例模式的懒汉模式的实现。\n\n    public final class EnumA extends Enum {\n    \n        private EnumA(String s, int i) {\n            super(s, i);\n        }\n    \n        public static EnumA[] values() {\n            EnumA aenuma[];\n            int i;\n            EnumA aenuma1[];\n            System.arraycopy(aenuma = ENUM$VALUES, 0, aenuma1 = new EnumA[i = aenuma.length], 0, i);\n            return aenuma1;\n        }\n    \n        public static EnumA valueOf(String s) {\n            return (EnumA)Enum.valueOf(EnumA, s);\n        }\n    \n        public static final EnumA Instance;\n        private static final EnumA ENUM$VALUES[];\n\n        static {\n            Instance = new EnumA(\"Instance\", 0);\n            ENUM$VALUES = (new EnumA[] {\n                Instance\n            });\n        }\n    }\n\n\n2.Enum类型确保了对象不能进行反序列化。这一特性是在enum源代码中禁止的。要使一个类可以被序列化，需要实现readObject()和writeObject()。\n\n    /**\n    * prevent default deserialization\n    */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        throw new InvalidObjectException(\"can't deserialize enum\");\n    }\n\n    private void readObjectNoData() throws ObjectStreamException {\n        throw new InvalidObjectException(\"can't deserialize enum\");\n    }\n\n    /**\n    * Throws CloneNotSupportedException.  This guarantees that enums     are never cloned, which is necessary to preserve their\"singleton\" status.\n    *\n    * @return (never returns)\n    */\n    protected final Object clone() throws CloneNotSupportedException {\n    \tthrow new CloneNotSupportedException();\n    }\n\n","source":"_posts/单例模式实现方式.markdown","raw":"title: 单例模式的实现方式\ntags: java, 设计模式\ncategory: 设计模式\n---\n单例模式是最简单的一种设计模式。单例模式的通俗理解就是在在程序中类有且只有一个实例存在。\n<!--more-->\n## 5种实现方式\n\n### 懒汉\n懒汉方式即等到需要用到对象的时候再生成实例。\n\n    public class LazyInitialization {\n    \tprivate static Resource resource;\n    \tpublic synchronized static Resource getInstance() {\n    \t\tif (resource == null) resource = new Resource();\n    \t\treturn resource;\n    \t}\n    }\n\n上面方式解决并发问题时用了synchronized，在方法上加锁。这种方式导致并发度不是很高，存在优化的地方。双重检验加锁通过减少加锁的粒度，来优化懒汉方式。\n\n### 双重检验加锁\n通过对实例加锁，减小了加锁的粒度，使并发度更高。\n\n    public class DoubleCheckedLocking {\n    \tprivate static volatile Resource resource;\n    \tpublic static Resource getInstance() {\n    \t\tif (resource == null) {\n\t    \t\tsynchronized(DoubleCheckedLocking.class) {\n\t    \t\t\tif (resource == null) {\n\t    \t\t\t\tresource = new Resource();\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t    \treturn resource;\n    \t}\n    }\n\n通常对双重检验加锁存在两种疑问：\n1.为什么使用volatile?\n其一：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。\n其二：resource = new Resource();这行代码在jvm中执行的过程为：\n\n - (1)给singleton分配内存\n - (2)调用构造函数来初始化成员变量\n - (3)将resource指向分配的内存空间，执行完这步resource才非空。\n \n\n在jvm中存在指令重排序的优化，也就是说步骤2、3的顺序不能保证。如果顺序是(1)-(3)-(2)，则在(3)执行完毕、(2)未执行之前，被线程二抢占了，这时 instance 已经是非 null 了(但却没有初始化)，所以线程二会直接返回 instance，然后使用，然后报错。\n由于volatile关键字可能会屏蔽掉虚拟机中的一些必要的代码优化，所以运行效率并不是很高。\n2.两个if的作用是什么？\n第一个if是如果实例已经存在，就没必要再生成实例了，也就没必要进行加锁了。第二个if是处理并发的问题。当两个线程a、b，a线程拿到锁，b线程等待锁，a线程实例化对象后，释放锁，b线程拿到锁但是这个时候类已经实例化了，没必要进行实例化操作了。所以两个if使得并发度更高。\n\n### 延长初始化占位类模式\n上面两种方式都是实现了延迟加载和线程安全。另外一种方法是使用静态内部类实现延迟加载和线程安全。在某些情况下，JVM已经隐含的为您执行了同步，这些情况下就不用自己再来进行同步控制了。包括：\n 1. 由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时\n 2. 访问final字段时\n \n代码如下：\n\n    public class ResourceFactory {\n    \tpublic static Resource getInstance() {\n    \t\treturn ResourceHolder.resource;\n    \t}\n    \tprivate ResourceFactory() {}\n    \tprivate static class ResourceHolder {\n    \t\tpublic static Resource resource = new Resource();\n\t    }\n    }\n此类方式是很好的实现单例的方式。\n### 饿汉\n通常在加载类的时候，就实例化对象。这是和懒汉不一样的地方。\n    \n    public class EagerInitialization {\n    \tprivate static Resource resource = new Resource();\n    \tpublic static Resource getResource() {\n    \t\treturn resource;\n        }\n    }\n\n### enum\nenum类型是java se5中引入的新特性。\n\n    public enum EnumA {\n\t    Instance;\n    }\n\n为什么enum类型可以保证类只有一个实例？\n1.enum类型反编译后，是一个final类。反编译后的类继承了Enum类型，并且是final类型的，所以这个类不能被继承。同时public static final EnumA Instance;是static final的，说明在程序中第一次用到的时候，会被加载。类似于单例模式的懒汉模式的实现。\n\n    public final class EnumA extends Enum {\n    \n        private EnumA(String s, int i) {\n            super(s, i);\n        }\n    \n        public static EnumA[] values() {\n            EnumA aenuma[];\n            int i;\n            EnumA aenuma1[];\n            System.arraycopy(aenuma = ENUM$VALUES, 0, aenuma1 = new EnumA[i = aenuma.length], 0, i);\n            return aenuma1;\n        }\n    \n        public static EnumA valueOf(String s) {\n            return (EnumA)Enum.valueOf(EnumA, s);\n        }\n    \n        public static final EnumA Instance;\n        private static final EnumA ENUM$VALUES[];\n\n        static {\n            Instance = new EnumA(\"Instance\", 0);\n            ENUM$VALUES = (new EnumA[] {\n                Instance\n            });\n        }\n    }\n\n\n2.Enum类型确保了对象不能进行反序列化。这一特性是在enum源代码中禁止的。要使一个类可以被序列化，需要实现readObject()和writeObject()。\n\n    /**\n    * prevent default deserialization\n    */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        throw new InvalidObjectException(\"can't deserialize enum\");\n    }\n\n    private void readObjectNoData() throws ObjectStreamException {\n        throw new InvalidObjectException(\"can't deserialize enum\");\n    }\n\n    /**\n    * Throws CloneNotSupportedException.  This guarantees that enums     are never cloned, which is necessary to preserve their\"singleton\" status.\n    *\n    * @return (never returns)\n    */\n    protected final Object clone() throws CloneNotSupportedException {\n    \tthrow new CloneNotSupportedException();\n    }\n\n","slug":"单例模式实现方式","published":1,"date":"2016-05-25T13:12:27.000Z","updated":"2016-05-25T13:15:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2eq001933fyqjxozzqg","content":"<p>单例模式是最简单的一种设计模式。单例模式的通俗理解就是在在程序中类有且只有一个实例存在。<br><a id=\"more\"></a></p>\n<h2 id=\"5种实现方式\"><a href=\"#5种实现方式\" class=\"headerlink\" title=\"5种实现方式\"></a>5种实现方式</h2><h3 id=\"懒汉\"><a href=\"#懒汉\" class=\"headerlink\" title=\"懒汉\"></a>懒汉</h3><p>懒汉方式即等到需要用到对象的时候再生成实例。</p>\n<pre><code>public class LazyInitialization {\n    private static Resource resource;\n    public synchronized static Resource getInstance() {\n        if (resource == null) resource = new Resource();\n        return resource;\n    }\n}\n</code></pre><p>上面方式解决并发问题时用了synchronized，在方法上加锁。这种方式导致并发度不是很高，存在优化的地方。双重检验加锁通过减少加锁的粒度，来优化懒汉方式。</p>\n<h3 id=\"双重检验加锁\"><a href=\"#双重检验加锁\" class=\"headerlink\" title=\"双重检验加锁\"></a>双重检验加锁</h3><p>通过对实例加锁，减小了加锁的粒度，使并发度更高。</p>\n<pre><code>public class DoubleCheckedLocking {\n    private static volatile Resource resource;\n    public static Resource getInstance() {\n        if (resource == null) {\n            synchronized(DoubleCheckedLocking.class) {\n                if (resource == null) {\n                    resource = new Resource();\n                }\n            }\n        }\n        return resource;\n    }\n}\n</code></pre><p>通常对双重检验加锁存在两种疑问：<br>1.为什么使用volatile?<br>其一：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。<br>其二：resource = new Resource();这行代码在jvm中执行的过程为：</p>\n<ul>\n<li>(1)给singleton分配内存</li>\n<li>(2)调用构造函数来初始化成员变量</li>\n<li>(3)将resource指向分配的内存空间，执行完这步resource才非空。</li>\n</ul>\n<p>在jvm中存在指令重排序的优化，也就是说步骤2、3的顺序不能保证。如果顺序是(1)-(3)-(2)，则在(3)执行完毕、(2)未执行之前，被线程二抢占了，这时 instance 已经是非 null 了(但却没有初始化)，所以线程二会直接返回 instance，然后使用，然后报错。<br>由于volatile关键字可能会屏蔽掉虚拟机中的一些必要的代码优化，所以运行效率并不是很高。<br>2.两个if的作用是什么？<br>第一个if是如果实例已经存在，就没必要再生成实例了，也就没必要进行加锁了。第二个if是处理并发的问题。当两个线程a、b，a线程拿到锁，b线程等待锁，a线程实例化对象后，释放锁，b线程拿到锁但是这个时候类已经实例化了，没必要进行实例化操作了。所以两个if使得并发度更高。</p>\n<h3 id=\"延长初始化占位类模式\"><a href=\"#延长初始化占位类模式\" class=\"headerlink\" title=\"延长初始化占位类模式\"></a>延长初始化占位类模式</h3><p>上面两种方式都是实现了延迟加载和线程安全。另外一种方法是使用静态内部类实现延迟加载和线程安全。在某些情况下，JVM已经隐含的为您执行了同步，这些情况下就不用自己再来进行同步控制了。包括：</p>\n<ol>\n<li>由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时</li>\n<li>访问final字段时</li>\n</ol>\n<p>代码如下：</p>\n<pre><code>public class ResourceFactory {\n    public static Resource getInstance() {\n        return ResourceHolder.resource;\n    }\n    private ResourceFactory() {}\n    private static class ResourceHolder {\n        public static Resource resource = new Resource();\n    }\n}\n</code></pre><p>此类方式是很好的实现单例的方式。</p>\n<h3 id=\"饿汉\"><a href=\"#饿汉\" class=\"headerlink\" title=\"饿汉\"></a>饿汉</h3><p>通常在加载类的时候，就实例化对象。这是和懒汉不一样的地方。</p>\n<pre><code>public class EagerInitialization {\n    private static Resource resource = new Resource();\n    public static Resource getResource() {\n        return resource;\n    }\n}\n</code></pre><h3 id=\"enum\"><a href=\"#enum\" class=\"headerlink\" title=\"enum\"></a>enum</h3><p>enum类型是java se5中引入的新特性。</p>\n<pre><code>public enum EnumA {\n    Instance;\n}\n</code></pre><p>为什么enum类型可以保证类只有一个实例？<br>1.enum类型反编译后，是一个final类。反编译后的类继承了Enum类型，并且是final类型的，所以这个类不能被继承。同时public static final EnumA Instance;是static final的，说明在程序中第一次用到的时候，会被加载。类似于单例模式的懒汉模式的实现。</p>\n<pre><code>public final class EnumA extends Enum {\n\n    private EnumA(String s, int i) {\n        super(s, i);\n    }\n\n    public static EnumA[] values() {\n        EnumA aenuma[];\n        int i;\n        EnumA aenuma1[];\n        System.arraycopy(aenuma = ENUM$VALUES, 0, aenuma1 = new EnumA[i = aenuma.length], 0, i);\n        return aenuma1;\n    }\n\n    public static EnumA valueOf(String s) {\n        return (EnumA)Enum.valueOf(EnumA, s);\n    }\n\n    public static final EnumA Instance;\n    private static final EnumA ENUM$VALUES[];\n\n    static {\n        Instance = new EnumA(&quot;Instance&quot;, 0);\n        ENUM$VALUES = (new EnumA[] {\n            Instance\n        });\n    }\n}\n</code></pre><p>2.Enum类型确保了对象不能进行反序列化。这一特性是在enum源代码中禁止的。要使一个类可以被序列化，需要实现readObject()和writeObject()。</p>\n<pre><code>/**\n* prevent default deserialization\n*/\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n    throw new InvalidObjectException(&quot;can&apos;t deserialize enum&quot;);\n}\n\nprivate void readObjectNoData() throws ObjectStreamException {\n    throw new InvalidObjectException(&quot;can&apos;t deserialize enum&quot;);\n}\n\n/**\n* Throws CloneNotSupportedException.  This guarantees that enums     are never cloned, which is necessary to preserve their&quot;singleton&quot; status.\n*\n* @return (never returns)\n*/\nprotected final Object clone() throws CloneNotSupportedException {\n    throw new CloneNotSupportedException();\n}\n</code></pre>","excerpt":"<p>单例模式是最简单的一种设计模式。单例模式的通俗理解就是在在程序中类有且只有一个实例存在。<br>","more":"</p>\n<h2 id=\"5种实现方式\"><a href=\"#5种实现方式\" class=\"headerlink\" title=\"5种实现方式\"></a>5种实现方式</h2><h3 id=\"懒汉\"><a href=\"#懒汉\" class=\"headerlink\" title=\"懒汉\"></a>懒汉</h3><p>懒汉方式即等到需要用到对象的时候再生成实例。</p>\n<pre><code>public class LazyInitialization {\n    private static Resource resource;\n    public synchronized static Resource getInstance() {\n        if (resource == null) resource = new Resource();\n        return resource;\n    }\n}\n</code></pre><p>上面方式解决并发问题时用了synchronized，在方法上加锁。这种方式导致并发度不是很高，存在优化的地方。双重检验加锁通过减少加锁的粒度，来优化懒汉方式。</p>\n<h3 id=\"双重检验加锁\"><a href=\"#双重检验加锁\" class=\"headerlink\" title=\"双重检验加锁\"></a>双重检验加锁</h3><p>通过对实例加锁，减小了加锁的粒度，使并发度更高。</p>\n<pre><code>public class DoubleCheckedLocking {\n    private static volatile Resource resource;\n    public static Resource getInstance() {\n        if (resource == null) {\n            synchronized(DoubleCheckedLocking.class) {\n                if (resource == null) {\n                    resource = new Resource();\n                }\n            }\n        }\n        return resource;\n    }\n}\n</code></pre><p>通常对双重检验加锁存在两种疑问：<br>1.为什么使用volatile?<br>其一：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。<br>其二：resource = new Resource();这行代码在jvm中执行的过程为：</p>\n<ul>\n<li>(1)给singleton分配内存</li>\n<li>(2)调用构造函数来初始化成员变量</li>\n<li>(3)将resource指向分配的内存空间，执行完这步resource才非空。</li>\n</ul>\n<p>在jvm中存在指令重排序的优化，也就是说步骤2、3的顺序不能保证。如果顺序是(1)-(3)-(2)，则在(3)执行完毕、(2)未执行之前，被线程二抢占了，这时 instance 已经是非 null 了(但却没有初始化)，所以线程二会直接返回 instance，然后使用，然后报错。<br>由于volatile关键字可能会屏蔽掉虚拟机中的一些必要的代码优化，所以运行效率并不是很高。<br>2.两个if的作用是什么？<br>第一个if是如果实例已经存在，就没必要再生成实例了，也就没必要进行加锁了。第二个if是处理并发的问题。当两个线程a、b，a线程拿到锁，b线程等待锁，a线程实例化对象后，释放锁，b线程拿到锁但是这个时候类已经实例化了，没必要进行实例化操作了。所以两个if使得并发度更高。</p>\n<h3 id=\"延长初始化占位类模式\"><a href=\"#延长初始化占位类模式\" class=\"headerlink\" title=\"延长初始化占位类模式\"></a>延长初始化占位类模式</h3><p>上面两种方式都是实现了延迟加载和线程安全。另外一种方法是使用静态内部类实现延迟加载和线程安全。在某些情况下，JVM已经隐含的为您执行了同步，这些情况下就不用自己再来进行同步控制了。包括：</p>\n<ol>\n<li>由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时</li>\n<li>访问final字段时</li>\n</ol>\n<p>代码如下：</p>\n<pre><code>public class ResourceFactory {\n    public static Resource getInstance() {\n        return ResourceHolder.resource;\n    }\n    private ResourceFactory() {}\n    private static class ResourceHolder {\n        public static Resource resource = new Resource();\n    }\n}\n</code></pre><p>此类方式是很好的实现单例的方式。</p>\n<h3 id=\"饿汉\"><a href=\"#饿汉\" class=\"headerlink\" title=\"饿汉\"></a>饿汉</h3><p>通常在加载类的时候，就实例化对象。这是和懒汉不一样的地方。</p>\n<pre><code>public class EagerInitialization {\n    private static Resource resource = new Resource();\n    public static Resource getResource() {\n        return resource;\n    }\n}\n</code></pre><h3 id=\"enum\"><a href=\"#enum\" class=\"headerlink\" title=\"enum\"></a>enum</h3><p>enum类型是java se5中引入的新特性。</p>\n<pre><code>public enum EnumA {\n    Instance;\n}\n</code></pre><p>为什么enum类型可以保证类只有一个实例？<br>1.enum类型反编译后，是一个final类。反编译后的类继承了Enum类型，并且是final类型的，所以这个类不能被继承。同时public static final EnumA Instance;是static final的，说明在程序中第一次用到的时候，会被加载。类似于单例模式的懒汉模式的实现。</p>\n<pre><code>public final class EnumA extends Enum {\n\n    private EnumA(String s, int i) {\n        super(s, i);\n    }\n\n    public static EnumA[] values() {\n        EnumA aenuma[];\n        int i;\n        EnumA aenuma1[];\n        System.arraycopy(aenuma = ENUM$VALUES, 0, aenuma1 = new EnumA[i = aenuma.length], 0, i);\n        return aenuma1;\n    }\n\n    public static EnumA valueOf(String s) {\n        return (EnumA)Enum.valueOf(EnumA, s);\n    }\n\n    public static final EnumA Instance;\n    private static final EnumA ENUM$VALUES[];\n\n    static {\n        Instance = new EnumA(&quot;Instance&quot;, 0);\n        ENUM$VALUES = (new EnumA[] {\n            Instance\n        });\n    }\n}\n</code></pre><p>2.Enum类型确保了对象不能进行反序列化。这一特性是在enum源代码中禁止的。要使一个类可以被序列化，需要实现readObject()和writeObject()。</p>\n<pre><code>/**\n* prevent default deserialization\n*/\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n    throw new InvalidObjectException(&quot;can&apos;t deserialize enum&quot;);\n}\n\nprivate void readObjectNoData() throws ObjectStreamException {\n    throw new InvalidObjectException(&quot;can&apos;t deserialize enum&quot;);\n}\n\n/**\n* Throws CloneNotSupportedException.  This guarantees that enums     are never cloned, which is necessary to preserve their&quot;singleton&quot; status.\n*\n* @return (never returns)\n*/\nprotected final Object clone() throws CloneNotSupportedException {\n    throw new CloneNotSupportedException();\n}\n</code></pre>"},{"title":"wait,notify,sleep","_content":"### wait与notify的配合\n\n在java中，进程同步是利用synchronized()实现的。java的object类型中，带有一个内存锁。如果一个线程获取该内存锁后，其他线程便无法访问该内存。只有获取了Object的对象锁后，才能使用该对象的wait和notify。可以通过synchronized()和lock来获得内存锁。以synchronized为例，synchronized(obj)获得当前对象的锁；synchronized(class)来获得类的锁，保证在一个时刻只有一个线程可以访问这个类的实例。\n<!--more-->\n![线程状态图](https://raw.githubusercontent.com/buptlsy/images/master/threads-java.gif)\n1. wait：线程获得对象锁后，主动释放对象锁，同时本线程休眠。\n2. notify：唤醒等待的线程。notify调用后，并不是马上释放对象锁，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，jvm会在wait()对象锁的线程中随机选取一线程，获取对象锁，唤醒线程，继续执行。\n\n### wait和sleep的区别\n\n1. Thread.sleep(), Object.wait()\n2. 两者都是暂停当前线程，释放cpu控制权\n3. wait在释放cpu时，同时释放了对象锁的控制\n","source":"_posts/wait_notify.md","raw":"---\ntitle: wait,notify,sleep\ncategories: java\ntags: java\n\n---\n### wait与notify的配合\n\n在java中，进程同步是利用synchronized()实现的。java的object类型中，带有一个内存锁。如果一个线程获取该内存锁后，其他线程便无法访问该内存。只有获取了Object的对象锁后，才能使用该对象的wait和notify。可以通过synchronized()和lock来获得内存锁。以synchronized为例，synchronized(obj)获得当前对象的锁；synchronized(class)来获得类的锁，保证在一个时刻只有一个线程可以访问这个类的实例。\n<!--more-->\n![线程状态图](https://raw.githubusercontent.com/buptlsy/images/master/threads-java.gif)\n1. wait：线程获得对象锁后，主动释放对象锁，同时本线程休眠。\n2. notify：唤醒等待的线程。notify调用后，并不是马上释放对象锁，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，jvm会在wait()对象锁的线程中随机选取一线程，获取对象锁，唤醒线程，继续执行。\n\n### wait和sleep的区别\n\n1. Thread.sleep(), Object.wait()\n2. 两者都是暂停当前线程，释放cpu控制权\n3. wait在释放cpu时，同时释放了对象锁的控制\n","slug":"wait_notify","published":1,"date":"2016-05-25T05:49:25.000Z","updated":"2016-05-25T06:21:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqw5p2es001c33fyxhklztpt","content":"<h3 id=\"wait与notify的配合\"><a href=\"#wait与notify的配合\" class=\"headerlink\" title=\"wait与notify的配合\"></a>wait与notify的配合</h3><p>在java中，进程同步是利用synchronized()实现的。java的object类型中，带有一个内存锁。如果一个线程获取该内存锁后，其他线程便无法访问该内存。只有获取了Object的对象锁后，才能使用该对象的wait和notify。可以通过synchronized()和lock来获得内存锁。以synchronized为例，synchronized(obj)获得当前对象的锁；synchronized(class)来获得类的锁，保证在一个时刻只有一个线程可以访问这个类的实例。<br><a id=\"more\"></a><br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/threads-java.gif\" alt=\"线程状态图\"></p>\n<ol>\n<li>wait：线程获得对象锁后，主动释放对象锁，同时本线程休眠。</li>\n<li>notify：唤醒等待的线程。notify调用后，并不是马上释放对象锁，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，jvm会在wait()对象锁的线程中随机选取一线程，获取对象锁，唤醒线程，继续执行。</li>\n</ol>\n<h3 id=\"wait和sleep的区别\"><a href=\"#wait和sleep的区别\" class=\"headerlink\" title=\"wait和sleep的区别\"></a>wait和sleep的区别</h3><ol>\n<li>Thread.sleep(), Object.wait()</li>\n<li>两者都是暂停当前线程，释放cpu控制权</li>\n<li>wait在释放cpu时，同时释放了对象锁的控制</li>\n</ol>\n","excerpt":"<h3 id=\"wait与notify的配合\"><a href=\"#wait与notify的配合\" class=\"headerlink\" title=\"wait与notify的配合\"></a>wait与notify的配合</h3><p>在java中，进程同步是利用synchronized()实现的。java的object类型中，带有一个内存锁。如果一个线程获取该内存锁后，其他线程便无法访问该内存。只有获取了Object的对象锁后，才能使用该对象的wait和notify。可以通过synchronized()和lock来获得内存锁。以synchronized为例，synchronized(obj)获得当前对象的锁；synchronized(class)来获得类的锁，保证在一个时刻只有一个线程可以访问这个类的实例。<br>","more":"<br><img src=\"https://raw.githubusercontent.com/buptlsy/images/master/threads-java.gif\" alt=\"线程状态图\"></p>\n<ol>\n<li>wait：线程获得对象锁后，主动释放对象锁，同时本线程休眠。</li>\n<li>notify：唤醒等待的线程。notify调用后，并不是马上释放对象锁，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，jvm会在wait()对象锁的线程中随机选取一线程，获取对象锁，唤醒线程，继续执行。</li>\n</ol>\n<h3 id=\"wait和sleep的区别\"><a href=\"#wait和sleep的区别\" class=\"headerlink\" title=\"wait和sleep的区别\"></a>wait和sleep的区别</h3><ol>\n<li>Thread.sleep(), Object.wait()</li>\n<li>两者都是暂停当前线程，释放cpu控制权</li>\n<li>wait在释放cpu时，同时释放了对象锁的控制</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"ciqw5p2dr000833fyaniwt35w","category_id":"ciqw5p2dl000533fye82v1vlh","_id":"ciqw5p2e5000g33fy6nvmbbl3"},{"post_id":"ciqw5p2da000033fyzbwrqgfa","category_id":"ciqw5p2dl000533fye82v1vlh","_id":"ciqw5p2e7000l33fy5gcdj27m"},{"post_id":"ciqw5p2dx000b33fykbxot2ht","category_id":"ciqw5p2dl000533fye82v1vlh","_id":"ciqw5p2e9000o33fyqwlwfbov"},{"post_id":"ciqw5p2dg000233fy5t39z3fu","category_id":"ciqw5p2dl000533fye82v1vlh","_id":"ciqw5p2ec000t33fyo2w2ztwu"},{"post_id":"ciqw5p2e7000m33fykd6j2iwd","category_id":"ciqw5p2dl000533fye82v1vlh","_id":"ciqw5p2ee000w33fy9qtbevc3"},{"post_id":"ciqw5p2dm000633fygdsa2miy","category_id":"ciqw5p2e7000j33fy9naag1jt","_id":"ciqw5p2ei001133fywrr4smhk"},{"post_id":"ciqw5p2ec000u33fyg4zowlxr","category_id":"ciqw5p2dl000533fye82v1vlh","_id":"ciqw5p2en001433fyq3aa6rjt"},{"post_id":"ciqw5p2e1000e33fydh6lvc3q","category_id":"ciqw5p2eb000r33fym1kay46e","_id":"ciqw5p2eq001733fydlrincbl"},{"post_id":"ciqw5p2ei001233fy9ns4eoys","category_id":"ciqw5p2eh001033fyr79lqf3w","_id":"ciqw5p2es001b33fy3v95d5c6"},{"post_id":"ciqw5p2e6000i33fyrsdwhjwx","category_id":"ciqw5p2eh001033fyr79lqf3w","_id":"ciqw5p2ev001e33fyf5zuwpr5"},{"post_id":"ciqw5p2eo001533fy939iy1sr","category_id":"ciqw5p2dl000533fye82v1vlh","_id":"ciqw5p2ey001i33fylaiitnro"},{"post_id":"ciqw5p2es001c33fyxhklztpt","category_id":"ciqw5p2dl000533fye82v1vlh","_id":"ciqw5p2ey001k33fyrihttq7j"},{"post_id":"ciqw5p2e9000p33fy460ivdr8","category_id":"ciqw5p2eq001833fyluc3m4hr","_id":"ciqw5p2ez001o33fy5rg839oj"},{"post_id":"ciqw5p2ee000x33fygoy4c5ks","category_id":"ciqw5p2eq001833fyluc3m4hr","_id":"ciqw5p2ez001p33fyzfbr94qy"},{"post_id":"ciqw5p2eq001933fyqjxozzqg","category_id":"ciqw5p2ey001m33fylfxe457r","_id":"ciqw5p2f1001s33fyrx74au6y"}],"PostTag":[{"post_id":"ciqw5p2dr000833fyaniwt35w","tag_id":"ciqw5p2dj000433fylh6rq2xd","_id":"ciqw5p2e0000d33fyxk75mxub"},{"post_id":"ciqw5p2da000033fyzbwrqgfa","tag_id":"ciqw5p2dj000433fylh6rq2xd","_id":"ciqw5p2e4000f33fy3cxiknel"},{"post_id":"ciqw5p2dx000b33fykbxot2ht","tag_id":"ciqw5p2dj000433fylh6rq2xd","_id":"ciqw5p2e7000k33fyu2uknba1"},{"post_id":"ciqw5p2dg000233fy5t39z3fu","tag_id":"ciqw5p2dj000433fylh6rq2xd","_id":"ciqw5p2e9000n33fyl6uxw53m"},{"post_id":"ciqw5p2e7000m33fykd6j2iwd","tag_id":"ciqw5p2dj000433fylh6rq2xd","_id":"ciqw5p2eb000s33fyiqt11jjm"},{"post_id":"ciqw5p2dm000633fygdsa2miy","tag_id":"ciqw5p2e5000h33fy6vjcpo5k","_id":"ciqw5p2ee000v33fytyvbh4qo"},{"post_id":"ciqw5p2ec000u33fyg4zowlxr","tag_id":"ciqw5p2dj000433fylh6rq2xd","_id":"ciqw5p2eh000z33fyg62iyukx"},{"post_id":"ciqw5p2e1000e33fydh6lvc3q","tag_id":"ciqw5p2ea000q33fy4qyfcbjr","_id":"ciqw5p2em001333fyvix70mtk"},{"post_id":"ciqw5p2e6000i33fyrsdwhjwx","tag_id":"ciqw5p2eg000y33fym9ntqs62","_id":"ciqw5p2er001a33fycn9pztbg"},{"post_id":"ciqw5p2eo001533fy939iy1sr","tag_id":"ciqw5p2dj000433fylh6rq2xd","_id":"ciqw5p2eu001d33fyroo9ud1j"},{"post_id":"ciqw5p2es001c33fyxhklztpt","tag_id":"ciqw5p2dj000433fylh6rq2xd","_id":"ciqw5p2ex001h33fydek271xa"},{"post_id":"ciqw5p2e9000p33fy460ivdr8","tag_id":"ciqw5p2ep001633fyeohdgj9u","_id":"ciqw5p2ey001j33fyrvduc32g"},{"post_id":"ciqw5p2ee000x33fygoy4c5ks","tag_id":"ciqw5p2ep001633fyeohdgj9u","_id":"ciqw5p2ez001n33fywwbug9jb"},{"post_id":"ciqw5p2ei001233fy9ns4eoys","tag_id":"ciqw5p2ey001l33fyxp93v7g1","_id":"ciqw5p2f0001r33fy0c9ckh6w"},{"post_id":"ciqw5p2eq001933fyqjxozzqg","tag_id":"ciqw5p2ez001q33fysqy0zlh8","_id":"ciqw5p2f1001t33fyiydl8frk"}],"Tag":[{"name":"java","_id":"ciqw5p2dj000433fylh6rq2xd"},{"name":"hexo","_id":"ciqw5p2e5000h33fy6vjcpo5k"},{"name":"linux","_id":"ciqw5p2ea000q33fy4qyfcbjr"},{"name":"mysql","_id":"ciqw5p2eg000y33fym9ntqs62"},{"name":"redis","_id":"ciqw5p2ep001633fyeohdgj9u"},{"name":"msql","_id":"ciqw5p2ey001l33fyxp93v7g1"},{"name":"java, 设计模式","_id":"ciqw5p2ez001q33fysqy0zlh8"}]}}